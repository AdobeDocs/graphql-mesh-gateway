{"version":3,"file":"component---src-pages-mesh-basic-transforms-replace-field-md-16f96f36c06b4b9a7be2.js","mappings":"oSAQaA,EAAe,CAAC,EAEvBC,EAAgBC,GAAQ,SAA6BC,GAEzD,OADAC,QAAQC,KAAK,aAAeH,EAAO,4EAC5B,eAASC,EACjB,EAEKG,EAAcL,EAAc,eAC5BM,EAAYN,EAAc,aAC1BO,EAAc,CAClBR,gBAEIS,EAAYC,EAAAA,EACH,SAASC,EAAT,GAGZ,IAHgC,WACjCC,GAEC,EADET,GACF,YACD,OAAO,SAACM,GAAD,UAAeD,EAAiBL,EAAhC,CAAuCS,WAAYA,EAAYC,QAAQ,eAG5E,eACE,GAAM,2BACL,uBAAYC,WAAW,MAAO,gBAA6B,eAC9D,kBAAK,QAAM,uBAAYA,WAAW,KAAM,gBAA6B,6EAA2E,uBAAYA,WAAW,KAAM,gBAA6B,wHAAsH,uBAAYA,WAAW,KAAM,sBAAmC,aAChY,eACE,GAAM,6CACH,0BAAwB,uBAAYA,WAAW,MAAO,yBAC3D,kBAAK,oBAAkB,uBAAYA,WAAW,KAAM,gBAA6B,oOACjF,kBAAK,cAAY,uBAAYA,WAAW,KAAM,gBAA6B,8EAA4E,cAAGA,WAAW,IACjK,KAAQ,6CACP,uBAAYA,WAAW,KAAM,wBAAwC,qCAAmC,uBAAYA,WAAW,KAAM,uBAAoC,gJAC9K,SAACR,EAAD,CAAaS,QAAQ,OAAOC,MAAM,OAAOH,QAAQ,iBACjD,kBAAK,8IAA4I,cAAGC,WAAW,IAC3J,KAAQ,kCACL,UAAc,yEAAuE,cAAGA,WAAW,IACtG,KAAQ,uBACP,uBAAYA,WAAW,KAAM,gBAA6B,cAAkB,MACjF,kBAAK,oDAAkD,uBAAYA,WAAW,KAAM,QAAqB,oBAAkB,uBAAYA,WAAW,KAAM,oBAAiC,YAAU,uBAAYA,WAAW,KAAM,SAAsB,cAAY,uBAAYA,WAAW,KAAM,gBAA6B,mBAAiB,uBAAYA,WAAW,KAAM,cAA2B,yCACrY,SAACP,EAAD,CAAWS,MAAM,gBAAgBC,OAAO,IAAIC,UAAU,mBAAmBL,QAAQ,eACjF,eACE,GAAM,aACL,uBAAYC,WAAW,MAAO,eACjC,qBAAK,iBAAMA,WAAW,MAClB,UAAa,iBACV,kSAgBP,eACE,GAAM,cACL,uBAAYA,WAAW,MAAO,gBACjC,qBAAK,iBAAMA,WAAW,MAClB,UAAa,uBACV,iSAmIV,CAEDH,EAAWQ,gBAAiB,C","sources":["webpack://graphql-mesh-gateway/./src/pages/mesh/basic/transforms/replace-field.md"],"sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\n\nimport DefaultLayout from \"/home/runner/work/graphql-mesh-gateway/graphql-mesh-gateway/node_modules/@adobe/gatsby-theme-aio/src/components/MDXFilter/index.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst InlineAlert = makeShortcode(\"InlineAlert\");\nconst CodeBlock = makeShortcode(\"CodeBlock\");\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"replacefield-transform\"\n    }}><inlineCode parentName=\"h1\">{`replaceField`}</inlineCode>{` transform`}</h1>\n    <p>{`The `}<inlineCode parentName=\"p\">{`replaceField`}</inlineCode>{` transform is deprecated. If you attempt to create an edge mesh with the `}<inlineCode parentName=\"p\">{`replaceField`}</inlineCode>{` transform, your edge mesh will not progress past the provisioning status. Alternatively, you can use the following `}<inlineCode parentName=\"p\">{`additonalResolvers`}</inlineCode>{` method.`}</p>\n    <h2 {...{\n      \"id\": \"replacing-fields-with-additionalresolvers\"\n    }}>{`Replacing fields with `}<inlineCode parentName=\"h2\">{`additionalResolvers`}</inlineCode></h2>\n    <p>{`Previously, the `}<inlineCode parentName=\"p\">{`replaceField`}</inlineCode>{` transform allowed you to replace the configuration properties of one field with another, hoisting field values from a subfield to its parent. This transform allowed you to clean up redundant queries or replace field types.`}</p>\n    <p>{`Since the `}<inlineCode parentName=\"p\">{`replaceField`}</inlineCode>{` transform is deprecated, you can achieve the same functionality by using `}<a parentName=\"p\" {...{\n        \"href\": \"../../advanced/extend/resolvers/index.md\"\n      }}><inlineCode parentName=\"a\">{`additionalResolvers`}</inlineCode></a>{` in your mesh configuration. The `}<inlineCode parentName=\"p\">{`additionalResolvers`}</inlineCode>{` property allows you to add custom resolvers to your mesh. These resolvers can replace fields, hoist values, or perform other custom logic.`}</p>\n    <InlineAlert variant=\"info\" slots=\"text\" mdxType=\"InlineAlert\" />\n    <p>{`Custom resolvers can hoist and replace existing fields as long as the field types are the same. If the field types are different, you can `}<a parentName=\"p\" {...{\n        \"href\": \"../../advanced/extend/index.md\"\n      }}>{`extend`}</a>{` the type to include a new field and hide the original field using a `}<a parentName=\"p\" {...{\n        \"href\": \"./filter-schema.md\"\n      }}><inlineCode parentName=\"a\">{`filterSchema`}</inlineCode>{` transform`}</a>{`.`}</p>\n    <p>{`The following example hoists the Adobe Commerce `}<inlineCode parentName=\"p\">{`name`}</inlineCode>{` field from the `}<inlineCode parentName=\"p\">{`ProductInterface`}</inlineCode>{` to the `}<inlineCode parentName=\"p\">{`label`}</inlineCode>{` field of `}<inlineCode parentName=\"p\">{`ProductImage`}</inlineCode>{` by adding the `}<inlineCode parentName=\"p\">{`replace.js`}</inlineCode>{` resolver to the mesh configuration.`}</p>\n    <CodeBlock slots=\"heading, code\" repeat=\"2\" languages=\"json, javascript\" mdxType=\"CodeBlock\" />\n    <h4 {...{\n      \"id\": \"meshjson\"\n    }}><inlineCode parentName=\"h4\">{`mesh.json`}</inlineCode></h4>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`{\n  \"meshConfig\": {\n    \"sources\": [\n      {\n        \"name\": \"AdobeCommerce\",\n        \"handler\": {\n          \"graphql\": {\n            \"endpoint\": \"https://venia.magento.com/graphql\"\n          }\n        },\n      }\n    ]\n    \"additionalResolvers\": [\"./replace.js\"]\n  }\n}\n`}</code></pre>\n    <h4 {...{\n      \"id\": \"replacejs\"\n    }}><inlineCode parentName=\"h4\">{`replace.js`}</inlineCode></h4>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`module.exports = {\n    resolvers: {\n        SimpleProduct: {\n            name: {\n                selectionSet: '{ name image { label } }',\n                resolve: (root) => {\n                    return root.image.label;\n                }\n            }\n        }\n    }\n} \n`}</code></pre>\n    {\n      /* \n      ## How the transform works\n      `from` defines your source, the field in the schema you want to replace.\n      ```json\n      [\n       {\n         \"from\": {\n           \"type\": \"Query\",\n           \"field\": \"books\"\n         }\n       }\n      ]\n      ```\n      In this case, we want to replace the field `books` in the type `Query`, which has the type `BooksApiResponse`.\n      `to` defines the target, and which field should replace your identified source field.\n      ```json\n      {\n       \"to\": {\n         \"type\": \"BooksApiResponse\",\n         \"field\": \"books\"\n       }\n      }\n      ```\n      To summarize, with the configuration above, we want the field `books` in type `Query` to be replaced from being of type `BooksApiResponse` to become type `[Book]`.\n      Finally, since we no longer have any reference to `BooksApiResponse` this becomes a loose type, which means the transform will purge it from the GraphQL schema.\n      ## Transform scopes\n      We explored how to use the transform to replace field Types.\n      The transform always replaces the type of source field with the type of the target.\n      However, the transform also allows you to pass a scope property, which values can be `config` or `hoistValue`.\n      We could say that the scope property could also take a `type` value, but since it's the minimum requirement to replace the Type, this is considered the default scope and so it wouldn't make sense to pass it when you desire just this behavior.\n      ### `scope:` config\n      The transform will replace the full field config when you pass `scope: config{:yaml}`.\n      A field config includes properties of the field such as `description`, `type`, `args`, `resolve`, `subscribe`, `deprecationReason`, `extensions`, `astNode`.\n      As you can see, this is very comprehensive as it includes things like arguments and the resolve and subscribes functions.\n      This can be useful when you have custom resolve functions on your target field. So you are happy to replace the source field entirely. However, you should be careful when you fully understand the implications of the behavior for your replaced field.\n      ### `scope: hoistValue`\n      We have seen how `hoistValue` can be useful in the full example described in the \"How to use?\" paragraph.\n      Once again, by default, the transform will replace the Type of the field only.\n      When passing `scope: hoistValue{:yaml}` in addition to replacing the Type, the transform will wrap the resolve function of the original field (source) with an extra function. This function intercepts the return value of the resolver to ultimately return only the direct child property that has the same name as the target field; hence performing value hoisting.\n      Taking into account the original schema shared above, originally, `Query.books` would return a value like this:\n      ```json\n      {\n       \"books\": {\n         \"books\": [\n           { \"title\": \"abc\", \"author\": \"def\" },\n           { \"title\": \"ghi\", \"author\": \"lmn\" }\n         ]\n       }\n      }\n      ```\n      But the wrapping function applied to the original resolver, when passing a `hoistValue` scope, will change the value above to this:\n      ```json\n      {\n       \"books\": [\n         { \"title\": \"abc\", \"author\": \"def\" },\n         { \"title\": \"ghi\", \"author\": \"lmn\" }\n       ]\n      }\n      ```\n      ## Additional type definitions\n      The examples shared so far are simple because we wanted to replace fields with other available fields in the original schema.\n      However, sometimes you might want to replace a field Type with something that is not available in the original schema.\n      In this case, the transform allows you to pass additional type definitions that will be injected into your schema to use them as target field Types.\n      Let's have a look at a Mesh config to be applied to the GraphQL schema shared above:\n      ```json\n      {\n       \"transforms\": [\n         {\n           \"replaceField\": {\n             \"typeDefs\": \"type NewAuthor {\\n  age: String\\n}\\n\",\n             \"replacements\": [\n               {\n                 \"from\": {\n                   \"type\": \"Author\",\n                   \"field\": \"age\"\n                 },\n                 \"to\": {\n                   \"type\": \"NewAuthor\",\n                   \"field\": \"age\"\n                 }\n               }\n             ]\n           }\n         }\n       ]\n      }\n      ```\n      The config above will change the type `Author` from this:\n      ```diff\n      type Author {\n       name: String!\n      - age: Int!\n      + age: String\n      }\n      ```\n      To this:\n      ```graphql\n      type Author {\n       name: String!\n       age: String\n      }\n      ```\n      ## Config API Reference\n      -  `typeDefs` (type: `Any`) - Additional type definitions, used to replace field types\n      -  `replacements` (type: `Array of Object`, required) - Array of rules to replace fields\n        -  `from` (type: `Object`, required):\n           -  `type` (type: `String`, required)\n           -  `field` (type: `String`, required)\n        -  `to` (type: `Object`, required):\n           -  `type` (type: `String`, required)\n           -  `field` (type: `String`, required)\n        -  `scope` (type: `String (config | hoistValue)`)\n        -  `composer` (type: `Any`)\n        -  `name` (type: `String`) */\n    }\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"names":["_frontmatter","makeShortcode","name","props","console","warn","InlineAlert","CodeBlock","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","mdxType","parentName","variant","slots","repeat","languages","isMDXComponent"],"sourceRoot":""}