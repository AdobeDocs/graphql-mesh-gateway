{"version":3,"file":"component---src-pages-reference-handlers-graphql-md-33e537252707a0b7b3e5.js","mappings":"8RAQaA,EAAe,CAAC,EACvBC,EAAc,CAClBD,aAAAA,GAEIE,EAAYC,EAAAA,EACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,GACF,YACD,OAAO,SAACJ,GAAD,UAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,eAG5E,eACE,GAAM,oBADR,qBAGA,0HAA2G,uBAAYC,WAAW,KAAvB,iBAA3G,gEACA,qBAAK,iBAAMA,WAAW,MAClB,UAAa,iBADZ,oMAeL,uEAAwD,cAAGA,WAAW,IAClE,KAAQ,0DAD4C,iCAAxD,2BAGA,eACE,GAAM,wBADR,yBAGA,qBAAK,iBAAMA,WAAW,MAClB,UAAa,iBADZ,gUAuCL,eACE,GAAM,uDADR,wDAGA,iLACA,qBAAK,iBAAMA,WAAW,MAClB,UAAa,iBADZ,sZAkBL,0CAA2B,uBAAYA,WAAW,KAAvB,SAA3B,4FAAwK,uBAAYA,WAAW,KAAvB,UAAxK,kBACA,eACE,GAAM,iBADR,kBAGA,uEAAwD,cAAGA,WAAW,IAClE,KAAQ,8CACP,uBAAYA,WAAW,KAAvB,uBAFL,SAEgF,cAAGA,WAAW,IAC1F,KAAQ,yEACP,uBAAYA,WAAW,KAAvB,wBAJL,4BAoGA,eACE,GAAM,wBADR,yBAGA,oBACE,eAAIA,WAAW,OAAK,uBAAYA,WAAW,MAAvB,YAApB,YAAqF,uBAAYA,WAAW,MAAvB,UAArF,mNAGA,eAAIA,WAAW,OAAK,uBAAYA,WAAW,MAAvB,iBAApB,YAA0F,uBAAYA,WAAW,MAAvB,OAA1F,kHACA,eAAIA,WAAW,OAAK,uBAAYA,WAAW,MAAvB,oBAApB,YAA6F,uBAAYA,WAAW,MAAvB,QAA7F,sHACA,eAAIA,WAAW,OAAK,uBAAYA,WAAW,MAAvB,oBAApB,YAA6F,uBAAYA,WAAW,MAAvB,WAA7F,0CACA,eAAIA,WAAW,OAAK,uBAAYA,WAAW,MAAvB,UAApB,YAAmF,uBAAYA,WAAW,MAAvB,uBAAnF,gDAoBL,CAEDJ,EAAWK,gBAAiB,C","sources":["webpack://graphql-mesh-gateway/./src/pages/reference/handlers/graphql.md"],"sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\n\nimport DefaultLayout from \"/home/runner/work/graphql-mesh-gateway/graphql-mesh-gateway/node_modules/@adobe/gatsby-theme-aio/src/components/MDXFilter/index.js\";\nexport const _frontmatter = {};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"graphql-handlers\"\n    }}>{`GraphQL handlers`}</h1>\n    <p>{`This handler allows you to load remote GraphQL schemas and use them with schema-stitching, based on `}<inlineCode parentName=\"p\">{`graphql-tools`}</inlineCode>{`. To get started, use the handler in your Mesh config file:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`{\n  \"sources\": [\n    {\n      \"name\": \"MyGraphQLApi\",\n      \"handler\": {\n        \"graphql\": {\n          \"endpoint\": \"https://my-service-url/graphql\"\n        }\n      }\n    }\n  ]\n}\n`}</code></pre>\n    <p>{`GraphQL handlers can also use local sources, see `}<a parentName=\"p\" {...{\n        \"href\": \"../handlers/index.md#reference-local-files-in-handlers\"\n      }}>{`Reference local file handlers`}</a>{` for more information.`}</p>\n    <h2 {...{\n      \"id\": \"headers-from-context\"\n    }}>{`Headers from context`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`{\n  \"sources\": [\n    {\n      \"name\": \"MyGraphQLApi\",\n      \"handler\": {\n        \"graphql\": {\n          \"endpoint\": \"https://my-service-url/graphql\",\n          \"operationHeaders\": {\n            \"Authorization\": \"Bearer {context.headers['x-my-api-token']}\"\n          }\n        }\n      }\n    }\n  ]\n}\n`}</code></pre>\n    {\n      /*\n      ### From Environment Variable\n      ```json\n      {\n       \"sources\": [\n         {\n           \"name\": \"MyGraphQLApi\",\n           \"handler\": {\n             \"graphql\": {\n             \"endpoint\": \"https://my-service-url/graphql\",\n               \"operationHeaders\": {\n                 \"Authorization\": \"Bearer {env.MY_API_TOKEN}\"\n               }\n             }\n           }\n         }\n       ]\n      }\n      ``` */\n    }\n    <h2 {...{\n      \"id\": \"fetching-sdl-or-introspection-from-cdn-or-somewhere\"\n    }}>{`Fetching SDL or introspection from CDN or somewhere`}</h2>\n    <p>{`Imagine that introspection is disabled in the production environment of your GraphQL source, and you want to provide your SDL or introspection separately:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`{\n    \"sources\": [\n        {\n            \"name\": \"MyGraphQLApi\",\n            \"handler\": {\n                \"graphql\": {\n                    \"endpoint\": \"https://api.github.com/graphql\",\n                    \"operationHeaders\": {\n                        \"Authorization\": \"Bearer {context.headers['GITHUB_TOKEN']}\"\n                    }\n                }\n            }\n        }\n    ]\n}\n`}</code></pre>\n    <p>{`In this case, CLI's `}<inlineCode parentName=\"p\">{`build`}</inlineCode>{` command won't save the introspection in the artifacts, so your Mesh won't start if the `}<inlineCode parentName=\"p\">{`source`}</inlineCode>{` URL is down.`}</p>\n    <h2 {...{\n      \"id\": \"local-schemas\"\n    }}>{`Local Schemas`}</h2>\n    <p>{`We recommend providing local schema by using the `}<a parentName=\"p\" {...{\n        \"href\": \"../../gateway/extending-unified-schema.md\"\n      }}><inlineCode parentName=\"a\">{`additionalTypeDefs`}</inlineCode></a>{` and `}<a parentName=\"p\" {...{\n        \"href\": \"../multiple-apis.md#extending-graphql-schema-with-additionaltypedefs\"\n      }}><inlineCode parentName=\"a\">{`additionalResolvers`}</inlineCode></a>{` configuration options.`}</p>\n    {\n      /* \n      ## Fetch Strategies and Multiple HTTP endpoints for the same source\n      If you want to have an advanced fetch strategy for the GraphQL source such as retrying twice or timeout in 30 seconds etc.\n      Also, you can have different HTTP endpoints for a single source, and you can configure Mesh to get a better execution flow.\n      For example, you can make a request to both endpoints and return the fastest response with `race` strategy.\n      All `fetch` strategies can be combined to create the ultimate execution flow:\n      ### `retry`\n      The `retry` mechanism allows you to specify the retry attempts for a single GraphQL endpoint/source.\n      The retry flow will execute in both conditions: a network error, or due to a runtime error.\n      ```json\n      {\n         \"sources\": [\n             {\n                 \"name\": \"uniswapv2\",\n                 \"handler\": {\n                     \"graphql\": {\n                         \"endpoint\": \"https://api.thegraph.com/subgraphs/name/uniswap/uniswap-v2\",\n                         \"retry\": 2\n                     }\n                 }\n             }\n         ]\n      }\n      ```\n      ### `timeout`\n      The `timeout` mechanism allows you to specify the `timeout` for a given GraphQL endpoint.\n      ```json\n      {\n         \"sources\": [\n             {\n                 \"name\": \"uniswapv2\",\n                 \"handler\": {\n                     \"graphql\": {\n                         \"endpoint\": \"https://api.thegraph.com/subgraphs/name/uniswap/uniswap-v2\",\n                         \"timeout\": 5000\n                     }\n                 }\n             }\n         ]\n      }\n      ```\n      ### `fallback`\n      The `fallback` mechanism allows you to specify more than one GraphQL endpoint, for the same source.\n      This is helpful if you have a fallback endpoint for the same GraphQL API.\n      ```json\n      {\n         \"sources\": [\n             {\n                 \"name\": \"uniswapv2\",\n                 \"handler\": {\n                     \"graphql\": {\n                         \"strategy\": \"fallback\",\n                         \"sources\": [\n                             {\n                                 \"endpoint\": \"https://bad-uniswap-v2-api.com\",\n                                 \"retry\": 2,\n                                 \"timeout\": 5000\n                             },\n                             {\n                                 \"endpoint\": \"https://api.thegraph.com/subgraphs/name/uniswap/uniswap-v2\"\n                             }\n                         ]\n                     }\n                 }\n             }\n         ]\n      }\n      ```\n      ### `race`\n      The `race` mechanism allows you to specify more than one GraphQL endpoint, for the same source, and race on every execution.\n      If you have different places that the service is deployed, this is useful to get the fastest response by racing them.\n      ```json\n      {\n         \"sources\": [\n             {\n                 \"name\": \"uniswapv2\",\n                 \"handler\": {\n                     \"graphql\": {\n                         \"strategy\": \"race\",\n                         \"sources\": [\n                             {\n                                 \"endpoint\": \"https://bad-uniswap-v2-api.com\"\n                             },\n                             {\n                                 \"endpoint\": \"https://api.thegraph.com/subgraphs/name/uniswap/uniswap-v2\"\n                             }\n                         ]\n                     }\n                 }\n             }\n         ]\n      }\n      ``` */\n    }\n    <h2 {...{\n      \"id\": \"config-api-reference\"\n    }}>{`Config API Reference`}</h2>\n    <ul>\n      <li parentName=\"ul\"><inlineCode parentName=\"li\">{`endpoint`}</inlineCode>{` (type: `}<inlineCode parentName=\"li\">{`String`}</inlineCode>{`, required) - A URL or file path to your remote GraphQL endpoint.\nIf you provide a path to a code file(js or ts),\nother options will be ignored and the schema exported from the file will be used directly.`}</li>\n      <li parentName=\"ul\"><inlineCode parentName=\"li\">{`schemaHeaders`}</inlineCode>{` (type: `}<inlineCode parentName=\"li\">{`Any`}</inlineCode>{`) - JSON object representing the Headers to add to the runtime of the API calls only for schema introspection`}</li>\n      <li parentName=\"ul\"><inlineCode parentName=\"li\">{`operationHeaders`}</inlineCode>{` (type: `}<inlineCode parentName=\"li\">{`JSON`}</inlineCode>{`) - JSON object representing the Headers to add to the runtime of the API calls only for operation during runtime`}</li>\n      <li parentName=\"ul\"><inlineCode parentName=\"li\">{`useGETForQueries`}</inlineCode>{` (type: `}<inlineCode parentName=\"li\">{`Boolean`}</inlineCode>{`) - Use HTTP GET for Query operations`}</li>\n      <li parentName=\"ul\"><inlineCode parentName=\"li\">{`method`}</inlineCode>{` (type: `}<inlineCode parentName=\"li\">{`String (GET | POST)`}</inlineCode>{`) - HTTP method used for GraphQL operations`}\n        {\n          /* \n          `customFetch` (type: `Any`) - Path to a custom W3 Compatible Fetch Implementation\n          `webSocketImpl` (type: `String`) - Path to a custom W3 Compatible WebSocket Implementation\n          `introspection` (type: `String`) - Path to the introspection\n          You can separately give schema introspection\n          `multipart` (type: `Boolean`) - Enable multipart/form data in order to support file uploads\n          `subscriptionsProtocol` (type: `String (SSE | WS | LEGACY_WS)`) - SSE - Server Sent Events\n          WS - New graphql-ws\n          LEGACY_WS - Legacy subscriptions-transport-ws\n          `retry` (type: `Int`) - Retry attempts if fails\n          `timeout` (type: `Int`) - Timeout in milliseconds\n          `batch` (type: `Boolean`) - Enable/Disable automatic query batching \n          */\n        }\n      </li>\n    </ul>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"sourceRoot":""}