{"version":3,"file":"component---src-pages-mesh-best-practices-multiple-apis-md-427e4d32777e8fa0589e.js","mappings":"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","sources":["webpack://graphql-mesh-gateway/./src/pages/mesh/best-practices/multiple-apis.md"],"sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\n\nimport DefaultLayout from \"/home/runner/work/graphql-mesh-gateway/graphql-mesh-gateway/node_modules/@adobe/gatsby-theme-aio/src/components/MDXFilter/index.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst InlineAlert = makeShortcode(\"InlineAlert\");\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"multiple-apis-recipe\"\n    }}>{`Multiple APIs recipe`}</h1>\n    <p>{`This topic describes how to use multiple APIs. Your mesh can merge different data sources into a single unified GraphQL Schema, but it is not an alternative to Schema Stitching, Apollo Federation, Bare Schema Merging, or another merging strategy.`}</p>\n    <p>{`In addition to `}<inlineCode parentName=\"p\">{`@apollo/gateway`}</inlineCode>{`, API Mesh supports subscriptions out-of-box.`}</p>\n    <p><a parentName=\"p\" {...{\n        \"href\": \"https://product.voxmedia.com/2020/11/2/21494865/to-federate-or-stitch-a-graphql-gateway-revisited\"\n      }}>{`Learn more key differences between Schema Stitching and Apollo Federation`}</a></p>\n    <h2 {...{\n      \"id\": \"extending-graphql-schema-with-additionaltypedefs\"\n    }}>{`Extending GraphQL Schema with `}<inlineCode parentName=\"h2\">{`additionalTypeDefs`}</inlineCode></h2>\n    <p>{`You can add new types or fields to the current unified GraphQL Schema by using the `}<inlineCode parentName=\"p\">{`additionalTypeDefs`}</inlineCode>{` configuration field.`}</p>\n    <p>{`For example, if we have the StackExchange API in our Mesh configuration:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`{\n  \"sources\": [\n    {\n      \"name\": \"StackExchange\",\n      \"handler\": {\n        \"openapi\": {\n          \"source\": \"https://raw.githubusercontent.com/grokify/api-specs/master/stackexchange/stackexchange-api-v2.2_openapi-v3.0.yaml\"\n        }\n      }\n    }\n  ],\n  \"additionalTypeDefs\": \"extend type Query {\\\\n  listQuestionsFromStackOverflow(first: Int!): [Question]\\\\n}\\\\n\"\n}\n`}</code></pre>\n    <p>{`We might want to add a new field under the `}<inlineCode parentName=\"p\">{`Query`}</inlineCode>{` root type named `}<inlineCode parentName=\"p\">{`viewsInPastMonth`}</inlineCode>{`, but we will need a resolver for this field.`}</p>\n    <h2 {...{\n      \"id\": \"declare-a-resolver-to-the-new-additionaltypedefs-by-using-additionalresolvers\"\n    }}>{`Declare a resolver to the new `}<inlineCode parentName=\"h2\">{`additionalTypeDefs`}</inlineCode>{` by using `}<inlineCode parentName=\"h2\">{`additionalResolvers`}</inlineCode></h2>\n    <p>{`The `}<inlineCode parentName=\"p\">{`additionalResolvers`}</inlineCode>{` field will make our new field executable in the unified schema:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`{\n  \"sources\": [\n    {\n      \"name\": \"StackExchange\",\n      \"handler\": {\n        \"openapi\": {\n          \"source\": \"https://raw.githubusercontent.com/grokify/api-specs/master/stackexchange/stackexchange-api-v2.2_openapi-v3.0.yaml\"\n        }\n      }\n    }\n  ],\n  \"additionalTypeDefs\": \"extend type Query {\\\\n  listQuestionsFromStackOverflow(first: Int!): [Question]\\\\n}\\\\n\",\n  \"additionalResolvers\": [\n    {\n      \"targetTypeName\": \"Query\",\n      \"targetFieldName\": \"listQuestionsFromStackOverflow\",\n      \"sourceName\": \"StackExchange\",\n      \"sourceTypeName\": \"Query\",\n      \"sourceFieldName\": \"listQuestions\",\n      \"sourceArgs\": {\n        \"pagesize\": \"{args.first}\"\n      },\n      \"result\": \"items\"\n    }\n  ]\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"combining-schemas-using-declarative-api\"\n    }}>{`Combining Schemas using declarative API`}</h2>\n    <p>{`We learned that we can combine multiple APIs in a mesh using `}<inlineCode parentName=\"p\">{`additionalTypeDefs`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`additionalResolvers`}</inlineCode>{`.`}</p>\n    <p>{`The following example has two different OpenAPI sources. We will add two new fields to the `}<inlineCode parentName=\"p\">{`Cities`}</inlineCode>{` type, and those fields have return types from the `}<inlineCode parentName=\"p\">{`Weather`}</inlineCode>{` API.`}</p>\n    <p>{`To achieve this, we will use `}<inlineCode parentName=\"p\">{`additionalResolvers`}</inlineCode>{` inside the mesh configuration file.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`{\n  \"sources\": [\n    {\n      \"name\": \"Cities\",\n      \"handler\": {\n        \"openapi\": {\n          \"source\": \"https://api.apis.guru/v2/specs/mashape.com/geodb/1.0.0/swagger.json\",\n          \"operationHeaders\": {\n            \"X-RapidAPI-Key\": \"a12b3c456defg78hij9kl0123m4no5pqr6stuv789wxyz01a23\"\n          }\n        }\n      }\n    },\n    {\n      \"name\": \"Weather\",\n      \"handler\": {\n        \"openapi\": {\n          \"source\": \"https://api.apis.guru/v2/specs/weatherbit.io/2.0.0/swagger.json\"\n        }\n      }\n    }\n  ],\n  \"additionalTypeDefs\": \"extend type PopulatedPlaceSummary {\\\\n  dailyForecast: [Forecast]\\\\n  todayForecast: Forecast\\\\n}\\\\n\",\n  \"additionalResolvers\": [\n    {\n      \"targetTypeName\": \"PopulatedPlaceSummary\",\n      \"targetFieldName\": \"dailyForecast\",\n      \"requiredSelectionSet\": \"{\\\\n  latitude\\\\n  longitude\\\\n}\\\\n\",\n      \"sourceName\": \"Weather\",\n      \"sourceTypeName\": \"Query\",\n      \"sourceFieldName\": \"getForecastDailyLatLatLonLon\",\n      \"sourceArgs\": {\n        \"lat\": \"{root.latitude}\",\n        \"lon\": \"{root.longitude}\",\n        \"key\": \"{context.headers['x-weather-api-key']}\"\n      },\n      \"result\": \"data\"\n    },\n    {\n      \"type\": \"PopulatedPlaceSummary\",\n      \"field\": \"todayForecast\",\n      \"requiredSelectionSet\": \"{\\\\n  latitude\\\\n  longitude\\\\n}\\\\n\",\n      \"sourceName\": \"Weather\",\n      \"sourceTypeName\": \"Query\",\n      \"sourceFieldName\": \"getForecastDailyLatLatLonLon\",\n      \"sourceArgs\": {\n        \"lat\": \"{root.latitude}\",\n        \"lon\": \"{root.longitude}\",\n        \"key\": \"{context.headers['x-weather-api-key']}\"\n      },\n      \"result\": \"data[0]\"\n    }\n  ]\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"merging-types-from-different-sources-type-merging\"\n    }}>{`Merging types from different sources (Type Merging)`}</h2>\n    <p>{`Imagine you have two different services, `}<inlineCode parentName=\"p\">{`Books`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`Authors`}</inlineCode>{`, which are exposing the following schemas:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`# Authors\ntype Query {\n  authors(ids: [ID!]): [Author!]!\n  author(id: ID!): Author!\n}\n\ntype Author {\n  id: ID!\n  name: String!\n}\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`# Books\ntype Query {\n  books(ids: [ID!]): [Book!]!\n  book(id: ID!): Book!\n  authorWithBooks(id: ID!): Author!\n  authorsWithBooks(ids: [ID!]): [Author!]!\n}\n\ntype Book {\n  id: ID!\n  title: String!\n  authorId: ID!\n}\n\ntype AuthorWithBooks {\n  id: ID!\n  books: [Book!]!\n}\n`}</code></pre>\n    <p>{`Then you could use the `}<a parentName=\"p\" {...{\n        \"href\": \"../basic/transforms/rename.md\"\n      }}><inlineCode parentName=\"a\">{`Rename`}</inlineCode></a>{` transform to rename `}<inlineCode parentName=\"p\">{`AuthorWithBooks`}</inlineCode>{` to `}<inlineCode parentName=\"p\">{`Author`}</inlineCode>{`.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`[\n  {\n    \"sources\": [\n      {\n        \"name\": \"BookService\",\n        \"handler\": null,\n        \"transforms\": [\n          {\n            \"rename\": {\n              \"renames\": [\n                {\n                  \"from\": {\n                    \"type\": \"AuthorWithBooks\"\n                  },\n                  \"to\": {\n                    \"type\": \"Author\"\n                  }\n                },\n                {\n                  \"from\": {\n                    \"type\": \"Query\",\n                    \"field\": \"authorWithBooks\"\n                  },\n                  \"to\": {\n                    \"type\": \"Query\",\n                    \"field\": \"author\"\n                  }\n                }\n              ]\n            }\n          }\n        ]\n      }\n    ]\n  }\n]\n`}</code></pre>\n    <p>{`After that `}<inlineCode parentName=\"p\">{`rename`}</inlineCode>{`, you would expect the following query to work, but it will fail because the mesh does not know which field belongs to which source and how to combine those.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`{\n  author(id: 0) {\n    id # This field is common\n    name # This field is from \\`AuthorService\\`\n    books { # This field is from \\`BookService\\`\n      id\n      title\n    }\n  }\n}\n`}</code></pre>\n    <p>{`You could add `}<inlineCode parentName=\"p\">{`additionalResolvers`}</inlineCode>{`, extract `}<inlineCode parentName=\"p\">{`books`}</inlineCode>{` from `}<inlineCode parentName=\"p\">{`AuthorWithBooks`}</inlineCode>{`, and return it as a `}<inlineCode parentName=\"p\">{`books`}</inlineCode>{` field of `}<inlineCode parentName=\"p\">{`Author`}</inlineCode>{` type, but this is unnecessarily complicated. So instead, we'll use Type Merging.`}</p>\n    <p>{`The following example indicates how to fetch entities from different sources:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`{\n  \"sources\": [\n    {\n      \"name\": \"AuthorService\",\n      \"handler\": null,\n      \"transforms\": [\n        {\n          \"typeMerging\": {\n            \"queryFields\": [\n              {\n                \"queryFieldName\": \"author\",\n                \"keyField\": \"id\"\n              }\n            ]\n          }\n        }\n      ]\n    },\n    {\n      \"name\": \"BookService\",\n      \"handler\": null,\n      \"transforms\": [\n        {\n          \"rename\": {\n            \"renames\": [\n              {\n                \"from\": {\n                  \"type\": \"AuthorWithBooks\"\n                },\n                \"to\": {\n                  \"type\": \"Author\"\n                }\n              },\n              {\n                \"from\": {\n                  \"type\": \"Query\",\n                  \"field\": \"authorWithBooks\"\n                },\n                \"to\": {\n                  \"type\": \"Query\",\n                  \"field\": \"author\"\n                }\n              },\n              {\n                \"from\": {\n                  \"type\": \"Query\",\n                  \"field\": \"authorsWithBooks\"\n                },\n                \"to\": {\n                  \"type\": \"Query\",\n                  \"field\": \"authors\"\n                }\n              }\n            ]\n          }\n        },\n        {\n          \"typeMerging\": {\n            \"queryFields\": [\n              {\n                \"queryFieldName\": \"book\",\n                \"keyField\": \"id\"\n              },\n              {\n                \"queryFieldName\": \"author\",\n                \"keyField\": \"id\"\n              }\n            ]\n          }\n        }\n      ]\n    }\n  ]\n}\n`}</code></pre>\n    <p>{`Now the previous query will work as expected.`}</p>\n    <p><a parentName=\"p\" {...{\n        \"href\": \"../basic/transforms/type-merging.md\"\n      }}>{`Learn more about the Type Merging transform`}</a>{`.`}</p>\n    <h2 {...{\n      \"id\": \"batching-requests-between-sources-to-prevent-an-n1-problem\"\n    }}>{`Batching requests between sources to prevent an N+1 problem`}</h2>\n    <h3 {...{\n      \"id\": \"in-type-merging\"\n    }}>{`In type merging`}</h3>\n    <p>{`The previous example works fine, but there is an N+1 problem. It sends `}<inlineCode parentName=\"p\">{`n`}</inlineCode>{` requests for `}<inlineCode parentName=\"p\">{`n`}</inlineCode>{` entities. But we have `}<inlineCode parentName=\"p\">{`authors`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`books`}</inlineCode>{`. Type Merging is smart enough to handle batching if you point it to a field that returns a list of entities. Let's update our mesh to the following:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`{\n  \"sources\": [\n    {\n      \"name\": \"AuthorService\",\n      \"handler\": null,\n      \"transforms\": [\n        {\n          \"typeMerging\": {\n            \"queryFields\": [\n              {\n                \"queryFieldName\": \"authors\",\n                \"keyField\": \"id\"\n              }\n            ]\n          }\n        }\n      ]\n    },\n    {\n      \"name\": \"BookService\",\n      \"handler\": null,\n      \"transforms\": [\n        {\n          \"rename\": {\n            \"renames\": [\n              {\n                \"from\": {\n                  \"type\": \"AuthorWithBooks\"\n                },\n                \"to\": {\n                  \"type\": \"Author\"\n                }\n              },\n              {\n                \"from\": {\n                  \"type\": \"Query\",\n                  \"field\": \"authorWithBooks\"\n                },\n                \"to\": {\n                  \"type\": \"Query\",\n                  \"field\": \"author\"\n                }\n              },\n              {\n                \"from\": {\n                  \"type\": \"Query\",\n                  \"field\": \"authorsWithBooks\"\n                },\n                \"to\": {\n                  \"type\": \"Query\",\n                  \"field\": \"authors\"\n                }\n              }\n            ]\n          }\n        },\n        {\n          \"typeMerging\": {\n            \"queryFields\": [\n              {\n                \"queryFieldName\": \"books\",\n                \"keyField\": \"id\"\n              },\n              {\n                \"queryFieldName\": \"authors\",\n                \"keyField\": \"id\"\n              }\n            ]\n          }\n        }\n      ]\n    }\n  ]\n}\n`}</code></pre>\n    <p>{`And now it batches the requests to the inner sources.`}</p>\n    <h3 {...{\n      \"id\": \"in-regular-additionalresolvers\"\n    }}>{`In regular `}<inlineCode parentName=\"h3\">{`additionalResolvers`}</inlineCode></h3>\n    <p>{`In the following example, we want to have a field called `}<inlineCode parentName=\"p\">{`author`}</inlineCode>{` under `}<inlineCode parentName=\"p\">{`Book`}</inlineCode>{` property and point it to the `}<inlineCode parentName=\"p\">{`author`}</inlineCode>{` property.`}</p>\n    <p>{`Normally, we would use the following definitions:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`{\n  \"additionalTypeDefs\": \"extend type Book {\\\\n  author: Author\\\\n}\\\\n\",\n  \"additionalResolvers\": [\n    {\n      \"sourceName\": \"AuthorService\",\n      \"sourceTypeName\": \"Query\",\n      \"sourceFieldName\": \"author\",\n      \"sourceArgs\": {\n        \"id\": \"{root.authorId}\"\n      },\n      \"targetTypeName\": \"Book\",\n      \"targetFieldName\": \"author\",\n      \"requiredSelectionSet\": \"{authorId}\"\n    }\n  ]\n}\n`}</code></pre>\n    <p>{`This creates an N+1 problem that we can solve by using the following format:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`{\n  \"additionalResolvers\": [\n    {\n      \"sourceName\": \"AuthorService\",\n      \"sourceTypeName\": \"Query\",\n      \"sourceFieldName\": \"authors\",\n      \"keyField\": \"authorId\",\n      \"keysArg\": \"ids\",\n      \"targetTypeName\": \"Book\",\n      \"targetFieldName\": \"author\"\n    }\n  ]\n}\n`}</code></pre>\n    <p>{`Now your mesh will batch the queries of `}<inlineCode parentName=\"p\">{`Book.author`}</inlineCode>{` by using the `}<inlineCode parentName=\"p\">{`authorId`}</inlineCode>{` field in `}<inlineCode parentName=\"p\">{`Query.authors`}</inlineCode>{`.`}</p>\n    <h2 {...{\n      \"id\": \"consuming-apollo-federation-services\"\n    }}>{`Consuming Apollo Federation Services`}</h2>\n    <p>{`The mesh uses `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/gmac/schema-stitching-handbook/tree/master/federation-services\"\n      }}>{`Schema Stitching`}</a>{` to consume the existing Apollo Federation services, so you can combine Federation and Type Merging.`}</p>\n    <p>{`Follow the Apollo Federation spec and integrate your existing Federated services. Your mesh can mix and match Federation and Stitching approaches including all other transforms (Type Merging, Rename, Filter, etc.).`}</p>\n    <p>{`You can also transform your existing non-federated schemas into a federated service.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`{\n  \"sources\": [\n    {\n      \"name\": \"accounts\",\n      \"handler\": {\n        \"graphql\": {\n          \"endpoint\": \"<your_url>\"\n        }\n      },\n      \"transforms\": [\n        {\n          \"federation\": {\n            \"types\": [\n              {\n                \"name\": \"Query\",\n                \"config\": {\n                  \"extend\": true\n                }\n              },\n              {\n                \"name\": \"User\",\n                \"config\": {\n                  \"keyFields\": [\n                    \"id\"\n                  ],\n                  \"resolveReference\": {\n                    \"queryFieldName\": \"user\"\n                  }\n                }\n              }\n            ]\n          }\n        }\n      ]\n    },\n    {\n      \"name\": \"reviews\",\n      \"handler\": {\n        \"graphql\": {\n          \"endpoint\": \"<your_url>\"\n        }\n      }\n    },\n    {\n      \"name\": \"products\",\n      \"handler\": {\n        \"graphql\": {\n          \"endpoint\": \"<your_url>\"\n        }\n      }\n    },\n    {\n      \"name\": \"inventory\",\n      \"handler\": {\n        \"graphql\": {\n          \"endpoint\": \"<your_url>\"\n        }\n      }\n    }\n  ]\n}\n`}</code></pre>\n    <InlineAlert variant=\"info\" slots=\"text\" mdxType=\"InlineAlert\" />\n    <p>{` You can view the `}<a parentName=\"p\" {...{\n        \"href\": \"../basic/transforms/federation.md\"\n      }}>{`federation transformer`}</a>{` documentation to learn more about adding federation metadata to a non-federated GraphQL Schema.`}</p>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"names":["_frontmatter","InlineAlert","name","props","console","warn","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","mdxType","parentName","variant","slots","isMDXComponent"],"sourceRoot":""}