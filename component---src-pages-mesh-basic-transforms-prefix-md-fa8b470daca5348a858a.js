"use strict";(self.webpackChunkgraphql_mesh_gateway=self.webpackChunkgraphql_mesh_gateway||[]).push([[3424],{31924:function(e,n,a){a.r(n),a.d(n,{_frontmatter:function(){return p},default:function(){return c}});var r=a(87462),t=a(45987),o=(a(35776),a(3905)),i=a(91515);const m=["components"],p={},d=(l="InlineAlert",function(e){return console.warn("Component "+l+" was not imported, exported, or provided by MDXProvider as global scope"),(0,o.mdx)("div",e)});var l;const s={_frontmatter:p},x=i.Z;function c(e){let{components:n}=e,a=(0,t.Z)(e,m);return(0,o.mdx)(x,(0,r.Z)({},s,a,{components:n,mdxType:"MDXLayout"}),(0,o.mdx)("h1",{id:"prefix-transform"},(0,o.mdx)("inlineCode",{parentName:"h1"},"prefix")," transform"),(0,o.mdx)("p",null,"The ",(0,o.mdx)("inlineCode",{parentName:"p"},"prefix")," transform allows you to add prefixes to existing types and root operations. ",(0,o.mdx)("inlineCode",{parentName:"p"},"prefix")," is similar to ",(0,o.mdx)("inlineCode",{parentName:"p"},"rename")," in that it allows you to modify names to avoid conflicts, simplify complicated names, and change the appearance of your query. In contrast with ",(0,o.mdx)("inlineCode",{parentName:"p"},"rename"),", ",(0,o.mdx)("inlineCode",{parentName:"p"},"prefix")," is simpler and only allows you to append a prefix to the existing name."),(0,o.mdx)("p",null,'You can use it to easily "namespace" APIs in your unified API and avoid conflicts.'),(0,o.mdx)("h2",{id:"usage"},"Usage"),(0,o.mdx)("p",null,"The following example adds the ",(0,o.mdx)("inlineCode",{parentName:"p"},"commerce_")," prefix to all Adobe Commerce source types:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "meshConfig": {\n    "sources": [\n      {\n        "name": "AdobeCommerce",\n        "transforms": [\n          {\n            "prefix": {\n              "mode": "wrap",\n              "value": "commerce_"\n            }\n          }\n        ],\n        "handler": {\n          "graphql": {\n            "endpoint": "https://venia.magento.com/graphql"\n          }\n        }\n      }\n    ]\n  }\n}\n')),(0,o.mdx)(d,{variant:"info",slots:"text",mdxType:"InlineAlert"}),(0,o.mdx)("p",null,"For information about ",(0,o.mdx)("inlineCode",{parentName:"p"},"bare")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"wrap")," modes, read the ",(0,o.mdx)("a",{parentName:"p",href:"./bare-vs-wrap.md"},"dedicated section"),"."),(0,o.mdx)("p",null,' In the example below, we differentiate our sources by adding an "AEM',(0,o.mdx)("em",{parentName:"p"},'" prefix to the ',(0,o.mdx)("a",{parentName:"em",href:"https://experienceleague.adobe.com/en/docs/experience-manager-65"},"AEM"),' source and a "Venia'),'" prefix to the ',(0,o.mdx)("a",{parentName:"p",href:"https://developer.adobe.com/commerce/pwa-studio/"},"PWA")," source."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "meshConfig": {\n    "sources": [\n      {\n        "name": "AEM",\n        "handler": {\n          "graphql": {\n            "endpoint": "https://example1.com/graphql"\n          }\n        },\n        "transforms": [\n          {\n            "prefix": {\n              "includeRootOperations": true,\n              "value": "AEM_"\n            }\n          }\n        ]\n      },\n       {\n        "name": "PWA",\n        "handler": {\n          "graphql": {\n            "endpoint": "https://example2.com/graphql"\n          }\n        },\n        "transforms": [\n          {\n            "prefix": {\n              "includeRootOperations": true,\n              "value": "Venia_"\n            }\n          }\n        ]\n      }\n    ]\n  },\n}\n')),(0,o.mdx)("h2",{id:"config-api-reference"},"Config API Reference"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"mode")," (type: ",(0,o.mdx)("inlineCode",{parentName:"li"},"String")," (",(0,o.mdx)("inlineCode",{parentName:"li"},"bare")," | ",(0,o.mdx)("inlineCode",{parentName:"li"},"wrap"),")) - Specify to apply prefix transform to bare schema or by wrapping original schema"),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"value")," (type: ",(0,o.mdx)("inlineCode",{parentName:"li"},"String"),") - The prefix to apply to the schema types. By default, the prefix is the API name."),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"ignore")," (type: ",(0,o.mdx)("inlineCode",{parentName:"li"},"Array of String"),", required) - List of ignored types"),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"includeRootOperations")," (type: ",(0,o.mdx)("inlineCode",{parentName:"li"},"Boolean"),") - Changes root types and changes the field names (default: false)"),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"includeTypes")," (type: ",(0,o.mdx)("inlineCode",{parentName:"li"},"Boolean"),") - Changes types (default: true)")))}c.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-mesh-basic-transforms-prefix-md-fa8b470daca5348a858a.js.map