{"version":3,"file":"component---src-pages-gateway-transforms-type-merging-md-955ff72d2200df33fb24.js","mappings":"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","sources":["webpack://graphql-mesh-gateway/./src/pages/gateway/transforms/type-merging.md"],"sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\n\nimport DefaultLayout from \"/home/runner/work/graphql-mesh-gateway/graphql-mesh-gateway/node_modules/@adobe/gatsby-theme-aio/src/components/MDXFilter/index.js\";\nexport const _frontmatter = {};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"typemerging-transform\"\n    }}><inlineCode parentName=\"h1\">{`typeMerging`}</inlineCode>{` transform`}</h1>\n    <p>{`Type Merging allows you to combine multiple sources by merging a type from each source. For example, you could combine responses from two different APIs on a single field, provided you `}<a parentName=\"p\" {...{\n        \"href\": \"./rename.md\"\n      }}>{`rename`}</a>{` the fields you want to stitch to the same name. For more information, see this `}<a parentName=\"p\" {...{\n        \"href\": \"../multiple-apis.md\"\n      }}>{`example`}</a>{`.`}</p>\n    <p>{`For example, you could combine responses from two different APIs on a single field, provided you rename the fields you want to stitch to the same name.`}</p>\n    <h2 {...{\n      \"id\": \"what-is-type-merging\"\n    }}>{`What is Type Merging?`}</h2>\n    <p>{`Imagine you have a mesh with two different GraphQL sources, `}<inlineCode parentName=\"p\">{`Books`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`Authors`}</inlineCode>{`, defined as the following:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`# Authors\ntype Query {\n  authors(ids: [ID!]): [Author!]!\n  author(id: ID!): Author!\n}\n\ntype Author {\n  id: ID!\n  name: String!\n}\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`# Books\ntype Query {\n  books(ids: [ID!]): [Book!]!\n  book(id: ID!): Book!\n  authorWithBooks(id: ID!): AuthorWithBooks!\n  authorsWithBooks(ids: [ID!]): [AuthorWithBooks!]!\n}\n\ntype Book {\n  id: ID!\n  title: String!\n  authorId: ID!\n}\n\ntype AuthorWithBooks {\n  id: ID!\n  books: [Book!]!\n}\n`}</code></pre>\n    <p>{`If you wanted to rename `}<inlineCode parentName=\"p\">{`AuthorWithBooks`}</inlineCode>{` to `}<inlineCode parentName=\"p\">{`Author`}</inlineCode>{` using the `}<a parentName=\"p\" {...{\n        \"href\": \"/graphql-mesh-gateway/docs/transforms/rename\"\n      }}><inlineCode parentName=\"a\">{`Rename`}</inlineCode></a>{` transform, you would create the following mesh.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`[\n    {\n        \"sources\": [\n            {\n                \"name\": \"BookService\",\n                \"handler\": null,\n                \"transforms\": [\n                    {\n                        \"rename\": {\n                            \"renames\": [\n                                {\n                                    \"from\": {\n                                        \"type\": \"AuthorWithBooks\"\n                                    },\n                                    \"to\": {\n                                        \"type\": \"Author\"\n                                    }\n                                },\n                                {\n                                    \"from\": {\n                                        \"type\": \"Query\",\n                                        \"field\": \"authorWithBooks\"\n                                    },\n                                    \"to\": {\n                                        \"type\": \"Query\",\n                                        \"field\": \"author\"\n                                    }\n                                }\n                            ]\n                        }\n                    }\n                ]\n            }\n        ]\n    }\n]\n`}</code></pre>\n    <p>{`After that `}<inlineCode parentName=\"p\">{`rename`}</inlineCode>{`, you would expect the following query to work, but it will fail because the mesh does not know which field belongs to which source and how to combine those.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`{\n  author(id: 0) {\n    id # This field is common\n    name # This field is from \\`AuthorService\\`\n    # This field is from \\`BookService\\`\n    books {\n      id\n      title\n    }\n  }\n}\n`}</code></pre>\n    <p>{`You could add `}<inlineCode parentName=\"p\">{`additionalResolvers`}</inlineCode>{`, extract `}<inlineCode parentName=\"p\">{`books`}</inlineCode>{` from `}<inlineCode parentName=\"p\">{`AuthorWithBooks`}</inlineCode>{`, and return it as a `}<inlineCode parentName=\"p\">{`books`}</inlineCode>{` field of `}<inlineCode parentName=\"p\">{`Author`}</inlineCode>{` type, but this is unnecessarily complicated. So instead, we'll use Type Merging.`}</p>\n    <p>{`The following example indicates how to fetch entities from different sources:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`{\n    \"sources\": [\n        {\n            \"name\": \"AuthorService\",\n            \"handler\": null,\n            \"transforms\": [\n                {\n                    \"typeMerging\": {\n                        \"queryFields\": [\n                            {\n                                \"queryFieldName\": \"author\",\n                                \"keyField\": \"id\"\n                            }\n                        ]\n                    }\n                }\n            ]\n        },\n        {\n            \"name\": \"BookService\",\n            \"handler\": null,\n            \"transforms\": [\n                {\n                    \"rename\": {\n                        \"renames\": [\n                            {\n                                \"from\": {\n                                    \"type\": \"AuthorWithBooks\"\n                                },\n                                \"to\": {\n                                    \"type\": \"Author\"\n                                }\n                            },\n                            {\n                                \"from\": {\n                                    \"type\": \"Query\",\n                                    \"field\": \"authorWithBooks\"\n                                },\n                                \"to\": {\n                                    \"type\": \"Query\",\n                                    \"field\": \"author\"\n                                }\n                            },\n                            {\n                                \"from\": {\n                                    \"type\": \"Query\",\n                                    \"field\": \"authorsWithBooks\"\n                                },\n                                \"to\": {\n                                    \"type\": \"Query\",\n                                    \"field\": \"authors\"\n                                }\n                            }\n                        ]\n                    }\n                },\n                {\n                    \"typeMerging\": {\n                        \"queryFields\": [\n                            {\n                                \"queryFieldName\": \"book\",\n                                \"keyField\": \"id\"\n                            },\n                            {\n                                \"queryFieldName\": \"author\",\n                                \"keyField\": \"id\"\n                            }\n                        ]\n                    }\n                }\n            ]\n        }\n    ]\n}\n`}</code></pre>\n    <p>{`Now the previous query will work as expected.`}</p>\n    <h3 {...{\n      \"id\": \"prevent-n1-problem-with-type-merging\"\n    }}>{`Prevent N+1 problem with Type Merging`}</h3>\n    <p>{`The previous example works fine, but there is an N+1 problem. It sends `}<inlineCode parentName=\"p\">{`n`}</inlineCode>{` requests for `}<inlineCode parentName=\"p\">{`n`}</inlineCode>{` entities. But we have `}<inlineCode parentName=\"p\">{`authors`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`books`}</inlineCode>{`. Type Merging is smart enough to handle batching if you point it to a field that returns a list of entities. Let's update our mesh to the following:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`{\n    \"sources\": [\n        {\n            \"name\": \"AuthorService\",\n            \"handler\": null,\n            \"transforms\": [\n                {\n                    \"typeMerging\": {\n                        \"queryFields\": [\n                            {\n                                \"queryFieldName\": \"authors\",\n                                \"keyField\": \"id\"\n                            }\n                        ]\n                    }\n                }\n            ]\n        },\n        {\n            \"name\": \"BookService\",\n            \"handler\": null,\n            \"transforms\": [\n                {\n                    \"rename\": {\n                        \"renames\": [\n                            {\n                                \"from\": {\n                                    \"type\": \"AuthorWithBooks\"\n                                },\n                                \"to\": {\n                                    \"type\": \"Author\"\n                                }\n                            },\n                            {\n                                \"from\": {\n                                    \"type\": \"Query\",\n                                    \"field\": \"authorWithBooks\"\n                                },\n                                \"to\": {\n                                    \"type\": \"Query\",\n                                    \"field\": \"author\"\n                                }\n                            },\n                            {\n                                \"from\": {\n                                    \"type\": \"Query\",\n                                    \"field\": \"authorsWithBooks\"\n                                },\n                                \"to\": {\n                                    \"type\": \"Query\",\n                                    \"field\": \"authors\"\n                                }\n                            }\n                        ]\n                    }\n                },\n                {\n                    \"typeMerging\": {\n                        \"queryFields\": [\n                            {\n                                \"queryFieldName\": \"books\",\n                                \"keyField\": \"id\"\n                            },\n                            {\n                                \"queryFieldName\": \"authors\",\n                                \"keyField\": \"id\"\n                            }\n                        ]\n                    }\n                }\n            ]\n        }\n    ]\n}\n`}</code></pre>\n    <p>{`And now it batches the requests to the inner sources.`}</p>\n    <h2 {...{\n      \"id\": \"using-the-type-merging-transform\"\n    }}>{`Using the Type Merging Transform`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`{\n  \"sources\": [\n    {\n      \"name\": \"AuthorService\",\n      \"handler\": {\n        \"graphql\": {\n          \"endpoint\": \"https://my-site.com/author-service-schema\"\n        }\n      },\n      \"transforms\": [\n        {\n          \"typeMerging\": {\n            \"queryFields\": [\n              {\n                \"queryFieldName\": \"authors\",\n                \"keyField\": \"id\"\n              }\n            ]\n          }\n        }\n      ]\n    },\n    {\n      \"name\": \"BookService\",\n      \"handler\": {\n        \"graphql\": {\n          \"endpoint\": \"https://my-site.com/book-service-schema.js\"\n        }\n      },\n      \"transforms\": [\n        {\n          \"rename\": {\n            \"renames\": [\n              {\n                \"from\": {\n                  \"type\": \"AuthorWithBooks\"\n                },\n                \"to\": {\n                  \"type\": \"Author\"\n                }\n              },\n              {\n                \"from\": {\n                  \"type\": \"Query\",\n                  \"field\": \"authorWithBooks\"\n                },\n                \"to\": {\n                  \"type\": \"Query\",\n                  \"field\": \"author\"\n                }\n              }\n            ]\n          }\n        },\n        {\n          \"typeMerging\": {\n            \"queryFields\": [\n              {\n                \"queryFieldName\": \"book\",\n                \"keyField\": \"id\"\n              },\n              {\n                \"queryFieldName\": \"author\",\n                \"keyField\": \"id\"\n              }\n            ]\n          }\n        }\n      ]\n    }\n  ]\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"config-api-reference\"\n    }}>{`Config API Reference`}</h2>\n    <ul>\n      <li parentName=\"ul\"><inlineCode parentName=\"li\">{`types`}</inlineCode>{` (type: `}<inlineCode parentName=\"li\">{`Array of Object`}</inlineCode>{`, required):`}\n        <ul parentName=\"li\">\n          <li parentName=\"ul\"><inlineCode parentName=\"li\">{`typeName`}</inlineCode>{` (type: `}<inlineCode parentName=\"li\">{`String`}</inlineCode>{`) - Name of the type (Query by default)`}</li>\n          <li parentName=\"ul\"><inlineCode parentName=\"li\">{`key`}</inlineCode>{` (type: `}<inlineCode parentName=\"li\">{`Object`}</inlineCode>{`) - Specifies a base selection set needed to merge the annotated type across subschemas.\nAnalogous to the `}<inlineCode parentName=\"li\">{`selectionSet`}</inlineCode>{` setting specified in the `}<a parentName=\"li\" {...{\n              \"href\": \"https://www.graphql-tools.com/docs/stitch-type-merging#basic-example\"\n            }}>{`merged type configuration`}</a>{`:`}\n            <pre parentName=\"li\"><code parentName=\"pre\" {...{}}>{`-  \\`selectionSet\\` (type: \\`String\\`, required)\n`}</code></pre>\n          </li>\n          <li parentName=\"ul\"><inlineCode parentName=\"li\">{`canonical`}</inlineCode>{` (type: `}<inlineCode parentName=\"li\">{`Boolean`}</inlineCode>{`) - Specifies types and fields\nthat provide a `}<a parentName=\"li\" {...{\n              \"href\": \"https://www.graphql-tools.com/docs/stitch-type-merging#canonical-definitions\"\n            }}>{`canonical definition`}</a>{` to be built into the gateway schema. Useful for selecting preferred characteristics among types and fields that overlap across subschemas. Root fields marked as canonical specify which subschema the field proxies for new queries entering the graph.`}</li>\n          <li parentName=\"ul\"><inlineCode parentName=\"li\">{`fields`}</inlineCode>{` (type: `}<inlineCode parentName=\"li\">{`Array of Object`}</inlineCode>{`, required):`}\n            <ul parentName=\"li\">\n              <li parentName=\"ul\"><inlineCode parentName=\"li\">{`fieldName`}</inlineCode>{` (type: `}<inlineCode parentName=\"li\">{`String`}</inlineCode>{`, required)`}</li>\n              <li parentName=\"ul\"><inlineCode parentName=\"li\">{`computed`}</inlineCode>{` (type: `}<inlineCode parentName=\"li\">{`Object`}</inlineCode>{`) - specifies a selection of fields required from other services to compute the value of this field.`}\n                <ul parentName=\"li\">\n                  <li parentName=\"ul\">{`These additional fields are only selected when the computed field is requested.`}</li>\n                  <li parentName=\"ul\">{`Analogous to the `}<a parentName=\"li\" {...{\n                      \"href\": \"https://www.graphql-tools.com/docs/stitch-type-merging#computed-fields\"\n                    }}>{`computed field`}</a>{` in merged type configuration.`}</li>\n                  <li parentName=\"ul\">{`Computed field dependencies must be sent into the sub service using an `}<a parentName=\"li\" {...{\n                      \"href\": \"https://www.graphql-tools.com/docs/stitch-directives-sdl#object-keys\"\n                    }}>{`object key`}</a>{`.`}</li>\n                  <li parentName=\"ul\"><inlineCode parentName=\"li\">{`selectionSet`}</inlineCode>{` (type: `}<inlineCode parentName=\"li\">{`String`}</inlineCode>{`, required)`}</li>\n                </ul>\n              </li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li parentName=\"ul\"><inlineCode parentName=\"li\">{`queryFields`}</inlineCode>{` (type: `}<inlineCode parentName=\"li\">{`Array of Object`}</inlineCode>{`, required) - Denotes a root field used to query a merged type across services.\nThe marked field's name is analogous to the `}<inlineCode parentName=\"li\">{`fieldName`}</inlineCode>{` setting in `}<a parentName=\"li\" {...{\n          \"href\": \"https://www.graphql-tools.com/docs/stitch-type-merging#basic-example\"\n        }}>{`merged type configuration`}</a>{`, while the field's arguments and return type are used to infer the merge configuration.\nDirective arguments tune the merge behavior:`}\n        <ul parentName=\"li\">\n          <li parentName=\"ul\"><inlineCode parentName=\"li\">{`queryFieldName`}</inlineCode>{` (type: `}<inlineCode parentName=\"li\">{`String`}</inlineCode>{`, required)`}</li>\n          <li parentName=\"ul\"><inlineCode parentName=\"li\">{`keyField`}</inlineCode>{` (type: `}<inlineCode parentName=\"li\">{`String`}</inlineCode>{`) - Specifies the name of a field to pick off origin objects as the key-value pair. When omitted, a `}<inlineCode parentName=\"li\">{`@key`}</inlineCode>{` directive must be included on the return type's definition to be built into an object key.\n`}<a parentName=\"li\" {...{\n              \"href\": \"https://www.graphql-tools.com/docs/stitch-directives-sdl#object-keys\"\n            }}>{`https://www.graphql-tools.com/docs/stitch-directives-sdl#object-keys`}</a></li>\n          <li parentName=\"ul\"><inlineCode parentName=\"li\">{`keyArg`}</inlineCode>{` (type: `}<inlineCode parentName=\"li\">{`String`}</inlineCode>{`) - Specifies which field argument receives the merge key. This may be omitted for fields with only one argument where the recipient can be inferred.`}</li>\n          <li parentName=\"ul\"><inlineCode parentName=\"li\">{`additionalArgs`}</inlineCode>{` (type: `}<inlineCode parentName=\"li\">{`String`}</inlineCode>{`) - Specifies a string of additional keys and values to apply to other arguments,\nformatted as `}<inlineCode parentName=\"li\">{`\\\\\"\\\\\"\\\\\" arg1: \"value\", arg2: \"value\" \\\\\"\\\\\"\\\\\"`}</inlineCode>{`.`}</li>\n          <li parentName=\"ul\"><inlineCode parentName=\"li\">{`key`}</inlineCode>{` (type: `}<inlineCode parentName=\"li\">{`Array of String`}</inlineCode>{`, required) - Advanced use only; Allows building a custom key just for the argument from the `}<inlineCode parentName=\"li\">{`selectionSet`}</inlineCode>{` included by the `}<inlineCode parentName=\"li\">{`@key`}</inlineCode>{` directive.`}</li>\n          <li parentName=\"ul\"><inlineCode parentName=\"li\">{`argsExpr`}</inlineCode>{` (type: `}<inlineCode parentName=\"li\">{`String`}</inlineCode>{`) - Advanced use only; This argument specifies a string expression that allows more customization of the input arguments. Rules for evaluation of this argument are as follows:`}</li>\n          <li parentName=\"ul\">{`Basic object parsing of the input key: `}<inlineCode parentName=\"li\">{`\"arg1: $key.arg1, arg2: $key.arg2\"`}</inlineCode></li>\n          <li parentName=\"ul\">{`Any expression enclosed by double brackets will be evaluated once for each of the requested keys, and then sent as a list: `}<inlineCode parentName=\"li\">{`\"input: \\\\{ keys: [[$key]] }\"`}</inlineCode></li>\n          <li parentName=\"ul\">{`Selections from the key can be referenced by using the $ sign and dot notation, for example `}<inlineCode parentName=\"li\">{`upcs: [[$key.upc]]`}</inlineCode>{` so that `}<inlineCode parentName=\"li\">{`$key.upc`}</inlineCode>{` refers to the `}<inlineCode parentName=\"li\">{`upc`}</inlineCode>{` field of the key.`}</li>\n        </ul>\n      </li>\n      <li parentName=\"ul\"><inlineCode parentName=\"li\">{`additionalConfiguration`}</inlineCode>{` (type: `}<inlineCode parentName=\"li\">{`Any`}</inlineCode>{`) - The path to a code file that has an additional type merging configuration`}</li>\n    </ul>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"sourceRoot":""}