{"version":3,"file":"component---src-pages-mesh-advanced-extend-index-md-77e45998c5e2483bec11.js","mappings":"oSAQaA,EAAe,CAAC,EAOvBC,GALgBC,EAKY,cALJ,SAA6BC,GAEzD,OADAC,QAAQC,KAAK,aAAeH,EAAO,4EAC5B,eAASC,EACjB,GAHqBD,MAMtB,MAAMI,EAAc,CAClBN,gBAEIO,EAAYC,EAAAA,EACH,SAASC,EAAT,GAGZ,IAHgC,WACjCC,GAEC,EADEP,GACF,YACD,OAAO,SAACI,GAAD,UAAeD,EAAiBH,EAAhC,CAAuCO,WAAYA,EAAYC,QAAQ,eAG5E,eACE,GAAM,8CACH,4BAA0B,uBAAYC,WAAW,MAAO,wBAC7D,kBAAK,2PACL,kBAAK,mBAAiB,uBAAYA,WAAW,KAAM,mBAAgC,kDACnF,mBAAG,cAAGA,WAAW,IACb,KAAQ,qGACL,+EACP,eACE,GAAM,oDACH,kCAAgC,uBAAYA,WAAW,MAAO,wBACnE,kBAAK,uFAAqF,uBAAYA,WAAW,KAAM,sBAAmC,0BAC1J,kBAAK,6EACL,qBAAK,iBAAMA,WAAW,MAClB,UAAa,iBACV,yYAcP,kBAAK,+CAA6C,uBAAYA,WAAW,KAAM,SAAsB,qBAAmB,uBAAYA,WAAW,KAAM,oBAAiC,kDACtL,eACE,GAAM,qDACH,wDACL,kBAAK,6CAA2C,uBAAYA,WAAW,KAAM,SAAsB,SAAO,uBAAYA,WAAW,KAAM,WAAwB,gDAC/J,qBAAK,iBAAMA,WAAW,MAClB,UAAa,oBACV,iJAWP,qBAAK,iBAAMA,WAAW,MAClB,UAAa,oBACV,mSAmBP,kBAAK,2BAAyB,cAAGA,WAAW,IACxC,KAAQ,qCACP,uBAAYA,WAAW,KAAM,WAA2B,yBAAuB,uBAAYA,WAAW,KAAM,mBAAgC,QAAM,uBAAYA,WAAW,KAAM,UAAuB,MAC3M,qBAAK,iBAAMA,WAAW,MAClB,UAAa,iBACV,yxBAqCP,kBAAK,eAAa,uBAAYA,WAAW,KAAM,UAAuB,kKACtE,qBAAK,iBAAMA,WAAW,MAClB,UAAa,oBACV,gMAWP,kBAAK,uDAAqD,cAAGA,WAAW,IACpE,KAAQ,0CACP,uBAAYA,WAAW,KAAM,wBAAwC,QAAM,cAAGA,WAAW,IAC1F,KAAQ,0CACL,gBAAoB,MAC3B,eACE,GAAM,8DACH,gEACL,kBAAK,2EAAyE,uBAAYA,WAAW,KAAM,KAAkB,kBAAgB,uBAAYA,WAAW,KAAM,KAAkB,2BAAyB,uBAAYA,WAAW,KAAM,WAAwB,SAAO,uBAAYA,WAAW,KAAM,SAAsB,0JACpU,qBAAK,iBAAMA,WAAW,MAClB,UAAa,iBACV,+nDA2EP,kBAAK,0DACL,eACE,GAAM,wCACH,yCACL,kBAAK,kBAAgB,cAAGA,WAAW,IAC/B,KAAQ,qFACL,oBAAwB,yGAC/B,kBAAK,2NACL,kBAAK,yFACL,qBAAK,iBAAMA,WAAW,MAClB,UAAa,iBACV,8pCA8DP,SAACX,EAAD,CAAaY,QAAQ,OAAOC,MAAM,OAAOH,QAAQ,iBACjD,kBAAK,sBAAoB,cAAGC,WAAW,IACnC,KAAQ,wCACL,0BAA8B,oGAGxC,CAEDH,EAAWM,gBAAiB,C","sources":["webpack://graphql-mesh-gateway/./src/pages/mesh/advanced/extend/index.md"],"sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\n\nimport DefaultLayout from \"/home/runner/work/graphql-mesh-gateway/graphql-mesh-gateway/node_modules/@adobe/gatsby-theme-aio/src/components/MDXFilter/index.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst InlineAlert = makeShortcode(\"InlineAlert\");\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"extend-your-schema-with-additionaltypedefs\"\n    }}>{`Extend your schema with `}<inlineCode parentName=\"h1\">{`AdditionalTypeDefs`}</inlineCode></h1>\n    <p>{`This topic describes how to use multiple APIs. Your mesh can merge different data sources into a single unified GraphQL Schema, but it is not an alternative to Schema Stitching, Apollo Federation, Bare Schema Merging, or another merging strategy.`}</p>\n    <p>{`In addition to `}<inlineCode parentName=\"p\">{`@apollo/gateway`}</inlineCode>{`, API Mesh supports subscriptions out-of-box.`}</p>\n    <p><a parentName=\"p\" {...{\n        \"href\": \"https://product.voxmedia.com/2020/11/2/21494865/to-federate-or-stitch-a-graphql-gateway-revisited\"\n      }}>{`Learn more key differences between Schema Stitching and Apollo Federation`}</a></p>\n    <h2 {...{\n      \"id\": \"extending-graphql-schema-with-additionaltypedefs\"\n    }}>{`Extending GraphQL Schema with `}<inlineCode parentName=\"h2\">{`additionalTypeDefs`}</inlineCode></h2>\n    <p>{`You can add new types or fields to the current unified GraphQL Schema by using the `}<inlineCode parentName=\"p\">{`additionalTypeDefs`}</inlineCode>{` configuration field.`}</p>\n    <p>{`For example, if we have the StackExchange API in our Mesh configuration:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`{\n  \"sources\": [\n    {\n      \"name\": \"StackExchange\",\n      \"handler\": {\n        \"openapi\": {\n          \"source\": \"https://raw.githubusercontent.com/grokify/api-specs/master/stackexchange/stackexchange-api-v2.2_openapi-v3.0.yaml\"\n        }\n      }\n    }\n  ],\n  \"additionalTypeDefs\": \"extend type Query {\\\\n  listQuestionsFromStackOverflow(first: Int!): [Question]\\\\n}\\\\n\"\n}\n`}</code></pre>\n    <p>{`We might want to add a new field under the `}<inlineCode parentName=\"p\">{`Query`}</inlineCode>{` root type named `}<inlineCode parentName=\"p\">{`viewsInPastMonth`}</inlineCode>{`, but we will need a resolver for this field.`}</p>\n    <h2 {...{\n      \"id\": \"merging-types-from-different-sources-type-merging\"\n    }}>{`Merging types from different sources (Type Merging)`}</h2>\n    <p>{`Imagine you have two different services, `}<inlineCode parentName=\"p\">{`Books`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`Authors`}</inlineCode>{`, which are exposing the following schemas:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`# Authors\ntype Query {\n  authors(ids: [ID!]): [Author!]!\n  author(id: ID!): Author!\n}\n\ntype Author {\n  id: ID!\n  name: String!\n}\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`# Books\ntype Query {\n  books(ids: [ID!]): [Book!]!\n  book(id: ID!): Book!\n  authorWithBooks(id: ID!): Author!\n  authorsWithBooks(ids: [ID!]): [Author!]!\n}\n\ntype Book {\n  id: ID!\n  title: String!\n  authorId: ID!\n}\n\ntype AuthorWithBooks {\n  id: ID!\n  books: [Book!]!\n}\n`}</code></pre>\n    <p>{`Then you could use the `}<a parentName=\"p\" {...{\n        \"href\": \"../../basic/transforms/rename.md\"\n      }}><inlineCode parentName=\"a\">{`Rename`}</inlineCode></a>{` transform to rename `}<inlineCode parentName=\"p\">{`AuthorWithBooks`}</inlineCode>{` to `}<inlineCode parentName=\"p\">{`Author`}</inlineCode>{`.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`[\n  {\n    \"sources\": [\n      {\n        \"name\": \"BookService\",\n        \"handler\": null,\n        \"transforms\": [\n          {\n            \"rename\": {\n              \"renames\": [\n                {\n                  \"from\": {\n                    \"type\": \"AuthorWithBooks\"\n                  },\n                  \"to\": {\n                    \"type\": \"Author\"\n                  }\n                },\n                {\n                  \"from\": {\n                    \"type\": \"Query\",\n                    \"field\": \"authorWithBooks\"\n                  },\n                  \"to\": {\n                    \"type\": \"Query\",\n                    \"field\": \"author\"\n                  }\n                }\n              ]\n            }\n          }\n        ]\n      }\n    ]\n  }\n]\n`}</code></pre>\n    <p>{`After that `}<inlineCode parentName=\"p\">{`rename`}</inlineCode>{`, you would expect the following query to work, but it will fail because the mesh does not know which field belongs to which source and how to combine those.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`{\n  author(id: 0) {\n    id # This field is common\n    name # This field is from \\`AuthorService\\`\n    books { # This field is from \\`BookService\\`\n      id\n      title\n    }\n  }\n}\n`}</code></pre>\n    <p>{`For other ways to extend the schema consider using `}<a parentName=\"p\" {...{\n        \"href\": \"./resolvers/programmatic-resolvers.md\"\n      }}><inlineCode parentName=\"a\">{`additionalResolvers`}</inlineCode></a>{` or `}<a parentName=\"p\" {...{\n        \"href\": \"../../basic/transforms/type-merging.md\"\n      }}>{`type merging`}</a>{`.`}</p>\n    <h2 {...{\n      \"id\": \"batching-requests-between-sources-to-prevent-an-n1-problem\"\n    }}>{`Batching requests between sources to prevent an N+1 problem`}</h2>\n    <p>{`The previous example works fine, but there is an N+1 problem. It sends `}<inlineCode parentName=\"p\">{`n`}</inlineCode>{` requests for `}<inlineCode parentName=\"p\">{`n`}</inlineCode>{` entities. But we have `}<inlineCode parentName=\"p\">{`authors`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`books`}</inlineCode>{`. Type Merging is smart enough to handle batching if you point it to a field that returns a list of entities. Let's update our mesh to the following:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`{\n  \"sources\": [\n    {\n      \"name\": \"AuthorService\",\n      \"handler\": null,\n      \"transforms\": [\n        {\n          \"typeMerging\": {\n            \"queryFields\": [\n              {\n                \"queryFieldName\": \"authors\",\n                \"keyField\": \"id\"\n              }\n            ]\n          }\n        }\n      ]\n    },\n    {\n      \"name\": \"BookService\",\n      \"handler\": null,\n      \"transforms\": [\n        {\n          \"rename\": {\n            \"renames\": [\n              {\n                \"from\": {\n                  \"type\": \"AuthorWithBooks\"\n                },\n                \"to\": {\n                  \"type\": \"Author\"\n                }\n              },\n              {\n                \"from\": {\n                  \"type\": \"Query\",\n                  \"field\": \"authorWithBooks\"\n                },\n                \"to\": {\n                  \"type\": \"Query\",\n                  \"field\": \"author\"\n                }\n              },\n              {\n                \"from\": {\n                  \"type\": \"Query\",\n                  \"field\": \"authorsWithBooks\"\n                },\n                \"to\": {\n                  \"type\": \"Query\",\n                  \"field\": \"authors\"\n                }\n              }\n            ]\n          }\n        },\n        {\n          \"typeMerging\": {\n            \"queryFields\": [\n              {\n                \"queryFieldName\": \"books\",\n                \"keyField\": \"id\"\n              },\n              {\n                \"queryFieldName\": \"authors\",\n                \"keyField\": \"id\"\n              }\n            ]\n          }\n        }\n      ]\n    }\n  ]\n}\n`}</code></pre>\n    <p>{`And now it batches the requests to the inner sources.`}</p>\n    <h2 {...{\n      \"id\": \"consuming-apollo-federation-services\"\n    }}>{`Consuming Apollo Federation Services`}</h2>\n    <p>{`The mesh uses `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/gmac/schema-stitching-handbook/tree/master/federation-services\"\n      }}>{`Schema Stitching`}</a>{` to consume the existing Apollo Federation services, so you can combine Federation and Type Merging.`}</p>\n    <p>{`Follow the Apollo Federation spec and integrate your existing Federated services. Your mesh can mix and match Federation and Stitching approaches including all other transforms (Type Merging, Rename, Filter, etc.).`}</p>\n    <p>{`You can also transform your existing non-federated schemas into a federated service.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`{\n  \"sources\": [\n    {\n      \"name\": \"accounts\",\n      \"handler\": {\n        \"graphql\": {\n          \"endpoint\": \"<your_url>\"\n        }\n      },\n      \"transforms\": [\n        {\n          \"federation\": {\n            \"types\": [\n              {\n                \"name\": \"Query\",\n                \"config\": {\n                  \"extend\": true\n                }\n              },\n              {\n                \"name\": \"User\",\n                \"config\": {\n                  \"keyFields\": [\n                    \"id\"\n                  ],\n                  \"resolveReference\": {\n                    \"queryFieldName\": \"user\"\n                  }\n                }\n              }\n            ]\n          }\n        }\n      ]\n    },\n    {\n      \"name\": \"reviews\",\n      \"handler\": {\n        \"graphql\": {\n          \"endpoint\": \"<your_url>\"\n        }\n      }\n    },\n    {\n      \"name\": \"products\",\n      \"handler\": {\n        \"graphql\": {\n          \"endpoint\": \"<your_url>\"\n        }\n      }\n    },\n    {\n      \"name\": \"inventory\",\n      \"handler\": {\n        \"graphql\": {\n          \"endpoint\": \"<your_url>\"\n        }\n      }\n    }\n  ]\n}\n`}</code></pre>\n    <InlineAlert variant=\"info\" slots=\"text\" mdxType=\"InlineAlert\" />\n    <p>{` You can view the `}<a parentName=\"p\" {...{\n        \"href\": \"../../basic/transforms/federation.md\"\n      }}>{`federation transformer`}</a>{` documentation to learn more about adding federation metadata to a non-federated GraphQL Schema.`}</p>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"names":["_frontmatter","InlineAlert","name","props","console","warn","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","mdxType","parentName","variant","slots","isMDXComponent"],"sourceRoot":""}