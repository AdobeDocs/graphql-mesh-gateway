{"version":3,"file":"component---src-pages-reference-handlers-openapi-md-cef374539bffd596b5b0.js","mappings":"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","sources":["webpack://graphql-mesh-gateway/./src/pages/reference/handlers/openapi.md"],"sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\n\nimport DefaultLayout from \"/home/runner/work/graphql-mesh-gateway/graphql-mesh-gateway/node_modules/@adobe/gatsby-theme-aio/src/components/MDXFilter/index.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst InlineAlert = makeShortcode(\"InlineAlert\");\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"openapi-handlers\"\n    }}>{`OpenAPI handlers`}</h1>\n    <p>{`This handler allows you to load remote or local `}<a parentName=\"p\" {...{\n        \"href\": \"https://swagger.io\"\n      }}>{`OpenAPI (2/3) and Swagger`}</a>{` schemas.`}</p>\n    <InlineAlert variant=\"info\" slots=\"text\" mdxType=\"InlineAlert\" />\n    <p>{`When using a Swagger schema, API Mesh can only access `}<inlineCode parentName=\"p\">{`application/json`}</inlineCode>{` content from the Swagger API definition. API Mesh does not accept a wildcard (`}<inlineCode parentName=\"p\">{`*/*`}</inlineCode>{`) as a content type.`}</p>\n    <p>{`You can import it using remote/local `}<inlineCode parentName=\"p\">{`.json`}</inlineCode>{` or `}<inlineCode parentName=\"p\">{`.yaml`}</inlineCode>{`. To use a local source with an API handler, see `}<a parentName=\"p\" {...{\n        \"href\": \"index.md#reference-local-files-in-handlers\"\n      }}>{`Reference local file handlers`}</a>{` for more information.`}</p>\n    <InlineAlert variant=\"info\" slots=\"text\" mdxType=\"InlineAlert\" />\n    <p>{`If your source handler's schema is modified, you must `}<a parentName=\"p\" {...{\n        \"href\": \"../../gateway/create-mesh.md#update-an-existing-mesh\"\n      }}>{`update your mesh`}</a>{` to allow API Mesh to cache any changes.`}</p>\n    <p>{`To get started, use the handler in your Mesh config file:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`{\n  \"sources\": [\n    {\n      \"name\": \"MyOpenapiApi\",\n      \"handler\": {\n        \"openapi\": {\n          \"source\": \"./monolith-open-api-schema.json\"\n        }\n      }\n    }\n  ]\n}\n`}</code></pre>\n    <InlineAlert variant=\"info\" slots=\"text\" mdxType=\"InlineAlert\" />\n    <p>{`This handler is based on the `}<a parentName=\"p\" {...{\n        \"href\": \"json-schema.md\"\n      }}>{`JSON Schema handler`}</a>{`, so its configurations also apply to the `}<inlineCode parentName=\"p\">{`openapi`}</inlineCode>{` handler.`}</p>\n    {\n      /* \n      ## Overriding default Query/Mutation operations\n      By default, OpenAPI-to-GraphQL will place all GET operations into Query fields and all other operations into Mutation fields; with this option, you can manually override this process.\n      To switch between Query and Mutation operations, and vice versa, you need to define an override rule that consists of OAS title, the path of the operation, the method of the operation, and the destination type (e.g. Query or Mutation).\n      See the following example:\n      ```json\n      {\n       \"sources\": [\n         {\n           \"name\": \"MyOpenapiApi\",\n           \"handler\": {\n             \"openapi\": {\n               \"source\": \"./monolith-open-api-schema.json\",\n               \"selectQueryOrMutationField\": [\n                 {\n                   \"title\": \"Weather Service v1\",\n                   \"path\": \"/weather/current\",\n                   \"method\": \"post\",\n                   \"type\": \"Query\"\n                 },\n                 {\n                   \"title\": \"Weather Service v1\",\n                   \"path\": \"/weather/forecast\",\n                   \"method\": \"get\",\n                   \"type\": \"Mutation\"\n                 }\n               ]\n             }\n           }\n         }\n       ]\n      }\n      ``` */\n    }\n    <h2 {...{\n      \"id\": \"naming-convention\"\n    }}>{`Naming convention`}</h2>\n    <p>{`We use the `}<inlineCode parentName=\"p\">{`operationId`}</inlineCode>{` for names, and aim to keep it as close as possible to the origin.`}</p>\n    <h3 {...{\n      \"id\": \"type-naming\"\n    }}>{`Type naming`}</h3>\n    <p>{`We adjust the `}<inlineCode parentName=\"p\">{`operationId`}</inlineCode>{` only when necessary according to the GraphQL spec:`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`- Characters, such as white space, \\`.\\`, \\`/\\`, \\`:\\` and \\`-\\`, are replaced with an underscore (\\`_\\`).\n- Other characters which are not digits or Latin letters are replaced with their character codes.\n- If the first character of a name is a digit, we prefix it with an underscore (\\`_\\`), because GraphQL does not allow initial digits.\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"unnamed-types\"\n    }}>{`Unnamed types`}</h3>\n    <p>{`We use path-based naming. So names could be structured like `}<inlineCode parentName=\"p\">{`query_getUsers_items_firstName`}</inlineCode>{`.`}</p>\n    <h2 {...{\n      \"id\": \"headers-from-context\"\n    }}>{`Headers from context`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`{\n  \"sources\": [\n    {\n      \"name\": \"MyGraphQLApi\",\n      \"handler\": {\n        \"openapi\": {\n          \"source\": \"./my-schema.json\",\n          \"operationHeaders\": {\n            \"Authorization\": \"Bearer {context.headers['x-my-api-token']}\"\n          }\n        }\n      }\n    }\n  ]\n}\n`}</code></pre>\n    {\n      /* \n      ### From Environmental Variable\n      `MY_API_TOKEN` is the name of the environmental variable that you have the value for.\n      ```json\n      {\n       \"sources\": [\n         {\n           \"name\": \"MyGraphQLApi\",\n           \"handler\": {\n             \"openapi\": {\n               \"source\": \"./my-schema.json\",\n               \"operationHeaders\": {\n                 \"Authorization\": \"Bearer {env.MY_API_TOKEN}\"\n               }\n             }\n           }\n         }\n       ]\n      }\n      ``` */\n    }\n    <h2 {...{\n      \"id\": \"advanced-cookies-handling\"\n    }}>{`Advanced cookies handling`}</h2>\n    <p>{`When building a web application, for security reasons, cookies are often used for authentication. Mobile applications on the other end, tend to use an HTTP header.`}</p>\n    {\n      /* \n      ### Accepting one cookie, header, or context value\n      We want to accept one of the following:\n      - an `accessToken` cookie\n      - an `Authorization` header\n      - an authorization value available in context (e.g. set by a GraphQL auth plugin)\n      We transmit the value to the Rest API as an `Authorization` header. GraphQL Mesh does not allow dynamic selection in the `meshrc.json` file, but we can work around that limitation.\n      ```json\n      {\n       \"sources\": [\n         {\n           \"name\": \"Rest\",\n           \"handler\": {\n             \"openapi\": {\n               \"source\": \"./openapi.yaml\",\n               \"baseUrl\": \"my-site/api/\",\n               \"operationHeaders\": {\n                 \"Authorization-Header\": \"{context.headers.authorization}\",\n                 \"Authorization-Cookie\": \"Bearer {context.cookies.accessToken}\"\n               },\n               \"customFetch\": \"./src/custom-fetch.js\"\n             }\n           }\n         }\n       ]\n      }\n      ```\n      Here in the `mesh.json` configuration, we store the cookie in `Authorization-Cookie` and the header in `Authorization-Header`. Now to introduce the logic needed to generate the proper `Authorization` header for the Rest API, we need to implement a `customFetch`. It will replace the `fetch` used by GraphQL Mesh to call the Rest API.\n      ```js\n      const fetch = require('node-fetch')\n      module.exports = (url, args, context) => {\n       // Set Authorization header dynamically to context value, or input cookie, or input header\n       args.headers['authorization'] = context.authorization || args.headers['authorization-cookie'] || args.headers['authorization-header'];\n       // Clean up headers forwarded to the Rest API\n       delete args.headers['authorization-cookie'];\n       delete args.headers['authorization-header'];\n       // Execute the fetch with the new headers\n       return fetch(url, args)\n      }\n      ```\n      Of course, `node-fetch` needs to be added to your project:\n      `npm install node-fetch` */\n    }\n    <h3 {...{\n      \"id\": \"setting--unsetting-the-cookie\"\n    }}>{`Setting / Unsetting the cookie`}</h3>\n    <p>{`Of course, being able to use your mesh as a Gateway for both the mobile application and web application is nice, but there's one thing missing: the setting of the cookie for the web application.`}</p>\n    <p>{`For that, we need to access the HTTP response that is sent back to the client. Luckily, we can do so in `}<inlineCode parentName=\"p\">{`additionalResolvers`}</inlineCode>{`. So we need to create two new resolvers, one for login and one for logout, and manage the cookie in their code.`}</p>\n    <p>{`The first step is to edit the `}<inlineCode parentName=\"p\">{`mesh.json`}</inlineCode>{` file, and add the following at the end:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`{\n  \"additionalTypeDefs\": \"extend type Mutation {\\\\n  login(credentials: Credentials!): String\\\\n  logout: Boolean\\\\n}\\\\n\",\n  \"additionalResolvers\": [\n    \"./src/additional-resolvers.js\"\n  ]\n}\n`}</code></pre>\n    <p>{`Then manage the cookie in the new resolvers:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`// lifespan of our cookie\nconst oneYear = 365 * 24 * 3600\n\nconst resolvers = {\n  Mutation: {\n    async login(root, args, context, info) {\n      // Call the Rest API's login operation\n      const result = await context.Rest.Mutation.accountLogin({\n        root,\n        args: {\n          credentials: args.credentials\n        },\n        context,\n        info\n      })\n      // if \\`result\\` contains a JWT token, you could instead decode it and set \\`Expires\\`\n      // to the JWT token's expiration date\n      res.set('Set-Cookie', \\`accessToken=\\${result}; Path=/; Secure; HttpOnly; Max-Age=\\${oneYear};\\`)\n\n      return result\n    },\n    logout(root, args, { res }) {\n      // use old date to unset cookie\n      res.set('Set-Cookie', \\`accessToken=logout; Path=/; Secure; HttpOnly; Expires=Thu, 1 Jan 1970 00:00:00 GMT;\\`)\n\n      return true\n    },\n  },\n}\n\nmodule.exports = { resolvers }\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"callbacks-as-subscriptions\"\n    }}>{`Callbacks as Subscriptions`}</h2>\n    <p>{`The OpenAPI handler can process OAS Callbacks as GraphQL Subscriptions. It uses your PubSub implementation to consume the data. But you have to define webhooks for individual callbacks to make it work.`}</p>\n    <h2 {...{\n      \"id\": \"loading-source-from-a-cdn\"\n    }}>{`Loading source from a CDN`}</h2>\n    <p>{`API Mesh supports loading sources from a CDN or schema registry by using the `}<inlineCode parentName=\"p\">{`source`}</inlineCode>{` property.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`{\n  \"sources\": [\n    {\n      \"name\": \"MyApi\",\n      \"handler\": {\n        \"openapi\": {\n          \"source\": \"https://cdn.<your cdn>.graphql\",\n          \"schemaHeaders\": {\n            \"X-CDN-Key\": \"abc123+d4/5e=\"\n          }\n        }\n      }\n    }\n  ]\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"config-api-reference\"\n    }}>{`Config API reference`}</h2>\n    <ul>\n      <li parentName=\"ul\"><inlineCode parentName=\"li\">{`source`}</inlineCode>{` (type: `}<inlineCode parentName=\"li\">{`Any`}</inlineCode>{`, required) - A pointer to your API source - could be a local file, remote file, or url endpoint`}</li>\n      <li parentName=\"ul\"><inlineCode parentName=\"li\">{`sourceFormat`}</inlineCode>{` (type: `}<inlineCode parentName=\"li\">{`String (json | yaml)`}</inlineCode>{`) - Format of the source file`}</li>\n      <li parentName=\"ul\"><inlineCode parentName=\"li\">{`operationHeaders`}</inlineCode>{` (type: `}<inlineCode parentName=\"li\">{`JSON`}</inlineCode>{`) - JSON object representing the Headers to add to the runtime of the API calls`}</li>\n      <li parentName=\"ul\"><inlineCode parentName=\"li\">{`schemaHeaders`}</inlineCode>{` (type: `}<inlineCode parentName=\"li\">{`JSON`}</inlineCode>{`) - If you are using a remote URL endpoint to fetch your schema, you can set headers for the HTTP request to fetch your schema.`}</li>\n      <li parentName=\"ul\"><inlineCode parentName=\"li\">{`baseUrl`}</inlineCode>{` (type: `}<inlineCode parentName=\"li\">{`String`}</inlineCode>{`) - Specifies the URL that all paths will be based on.\nOverrides the server object in the OAS.`}</li>\n      <li parentName=\"ul\"><inlineCode parentName=\"li\">{`qs`}</inlineCode>{` (type: `}<inlineCode parentName=\"li\">{`JSON`}</inlineCode>{`) - JSON object representing the query search parameters to add to the API calls`}</li>\n      <li parentName=\"ul\"><inlineCode parentName=\"li\">{`includeHttpDetails`}</inlineCode>{` (type: `}<inlineCode parentName=\"li\">{`Boolean`}</inlineCode>{`) - Include HTTP Response details to the result object`}</li>\n    </ul>\n    {\n      /* \n      `addLimitArgument` (type: `Boolean`) - Auto-generate a 'limit' argument for all fields that return lists of objects, including ones produced by links\n      `genericPayloadArgName` (type: `Boolean`) - Set argument name for mutation payload to 'requestBody'. If false, name defaults to camelCased pathname\n      `selectQueryOrMutationField` (type: `Array of Object`) - Allows to explicitly override the default operation (Query or Mutation) for any OAS operation:\n         `title` (type: `String`) - OAS Title\n         `path` (type: `String`) - Operation Path\n         `type` (type: `String (query | mutation | Query | Mutation)`) - Target Root Type for this operation\n         `method` (type: `String`) - Which method is used for this operation\n      `provideErrorExtensions` (type: `Boolean`) - Overwrite automatic wrapping of errors into GraphqlErrors\n      `operationIdFieldNames` (type: `Boolean`) - Field names can only be sanitized operationIds \n      By default, query field names are based on the return type name and mutation field names are based on the operationId, which may be generated if it does not exist.\n      This option forces OpenAPI handler to only create field names based on the operationId.\n      */\n    }\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"names":["name","_frontmatter","InlineAlert","props","console","warn","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","mdxType","parentName","variant","slots","isMDXComponent"],"sourceRoot":""}