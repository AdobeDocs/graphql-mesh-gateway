"use strict";(self.webpackChunkgraphql_mesh_gateway=self.webpackChunkgraphql_mesh_gateway||[]).push([[8177],{31830:function(e,n,a){a.r(n),a.d(n,{_frontmatter:function(){return p},default:function(){return u}});var t=a(87462),r=a(45987),i=(a(35776),a(3905)),o=a(91515);const m=["components"],p={},l=(d="InlineAlert",function(e){return console.warn("Component "+d+" was not imported, exported, or provided by MDXProvider as global scope"),(0,i.mdx)("div",e)});var d;const s={_frontmatter:p},x=o.Z;function u(e){let{components:n}=e,a=(0,r.Z)(e,m);return(0,i.mdx)(x,(0,t.Z)({},s,a,{components:n,mdxType:"MDXLayout"}),(0,i.mdx)("h1",{id:"prefix-transform"},(0,i.mdx)("inlineCode",{parentName:"h1"},"prefix")," transform"),(0,i.mdx)("p",null,"The ","[Prefix]"," transform allows you to add prefixes to existing types and root operations. ",(0,i.mdx)("inlineCode",{parentName:"p"},"prefix")," is similar to ",(0,i.mdx)("inlineCode",{parentName:"p"},"rename")," in that it allows you to modify names to avoid conflicts, simplify complicated names, and change the appearance of your query. In contrast with ",(0,i.mdx)("inlineCode",{parentName:"p"},"rename"),", ",(0,i.mdx)("inlineCode",{parentName:"p"},"prefix")," is simpler and only allows you to append a prefix to the existing name."),(0,i.mdx)("p",null,'You can use it to easily "namespace" APIs in your unified API and avoid conflicts.'),(0,i.mdx)("h2",{id:"usage"},"Usage"),(0,i.mdx)("p",null,"The following example adds the ",(0,i.mdx)("inlineCode",{parentName:"p"},"commerce_")," prefix to all Adobe Commerce source types:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "meshConfig": {\n    "sources": [\n      {\n        "name": "AdobeCommerce",\n        "transforms": [\n          {\n            "prefix": {\n              "mode": "wrap",\n              "value": "commerce_"\n            }\n          }\n        ],\n        "handler": {\n          "graphql": {\n            "endpoint": "https://venia.magento.com/graphql"\n          }\n        }\n      }\n    ]\n  }\n}\n')),(0,i.mdx)(l,{variant:"info",slots:"text",mdxType:"InlineAlert"}),(0,i.mdx)("p",null,"For information about ",(0,i.mdx)("inlineCode",{parentName:"p"},"bare")," and ",(0,i.mdx)("inlineCode",{parentName:"p"},"wrap")," modes, read the ",(0,i.mdx)("a",{parentName:"p",href:"./bare-vs-wrap.md"},"dedicated section"),"."),(0,i.mdx)("p",null,' In the example below, we differentiate our sources by adding an "AEM',(0,i.mdx)("em",{parentName:"p"},'" prefix to the ',"[AEM]",' source and a "Venia'),'" prefix to the ',"[PWA]"," source."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "meshConfig": {\n    "sources": [\n      {\n        "name": "AEM",\n        "handler": {\n          "graphql": {\n            "endpoint": "https://example1.com/graphql"\n          }\n        },\n        "transforms": [\n          {\n            "prefix": {\n              "includeRootOperations": true,\n              "value": "AEM_"\n            }\n          }\n        ]\n      },\n       {\n        "name": "PWA",\n        "handler": {\n          "graphql": {\n            "endpoint": "https://example2.com/graphql"\n          }\n        },\n        "transforms": [\n          {\n            "prefix": {\n              "includeRootOperations": true,\n              "value": "Venia_"\n            }\n          }\n        ]\n      }\n    ]\n  },\n}\n')),(0,i.mdx)("h2",{id:"config-api-reference"},"Config API Reference"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"mode")," (type: ",(0,i.mdx)("inlineCode",{parentName:"li"},"String")," (",(0,i.mdx)("inlineCode",{parentName:"li"},"bare")," | ",(0,i.mdx)("inlineCode",{parentName:"li"},"wrap"),")) - Specify to apply prefix transform to bare schema or by wrapping original schema"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"value")," (type: ",(0,i.mdx)("inlineCode",{parentName:"li"},"String"),") - The prefix to apply to the schema types. By default, the prefix is the API name."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"ignore")," (type: ",(0,i.mdx)("inlineCode",{parentName:"li"},"Array of String"),", required) - List of ignored types"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"includeRootOperations")," (type: ",(0,i.mdx)("inlineCode",{parentName:"li"},"Boolean"),") - Changes root types and changes the field names (default: false)"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"includeTypes")," (type: ",(0,i.mdx)("inlineCode",{parentName:"li"},"Boolean"),") - Changes types (default: true)")))}u.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-reference-transforms-prefix-md-58ec275a3382d8ab757f.js.map