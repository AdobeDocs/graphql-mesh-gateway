{"version":3,"file":"component---src-pages-reference-transforms-replace-field-md-95e465d3dda4f7c8c12e.js","mappings":"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","sources":["webpack://graphql-mesh-gateway/./src/pages/reference/transforms/replace-field.md"],"sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\n\nimport DefaultLayout from \"/home/runner/work/graphql-mesh-gateway/graphql-mesh-gateway/node_modules/@adobe/gatsby-theme-aio/src/components/MDXFilter/index.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst InlineAlert = makeShortcode(\"InlineAlert\");\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"replacefield-transform\"\n    }}><inlineCode parentName=\"h1\">{`replaceField`}</inlineCode>{` transform`}</h1>\n    <p>{`The `}<inlineCode parentName=\"p\">{`replaceField`}</inlineCode>{` transform allows you to replace the configuration properties of a GraphQL field (source) with the ones of another field (target).`}</p>\n    <p>{`The `}<inlineCode parentName=\"p\">{`replace-field`}</inlineCode>{` transforms allow you to replace the configuration properties of one field with another. This allows you to hoist field values from a subfield to its parent.`}</p>\n    <p>{`Use this transform to clean up redundant queries or replace field types.\nIt can be customized to completely replace and/or compose resolve functions with a great degree of customization.`}</p>\n    <InlineAlert variant=\"info\" slots=\"text\" mdxType=\"InlineAlert\" />\n    <p>{`Currently, this transform supports `}<inlineCode parentName=\"p\">{`bare`}</inlineCode>{` mode only. For information about `}<inlineCode parentName=\"p\">{`bare`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`wrap`}</inlineCode>{` modes, read the `}<a parentName=\"p\" {...{\n        \"href\": \"index.md#two-different-modes\"\n      }}>{`dedicated section`}</a>{`.`}</p>\n    <h2 {...{\n      \"id\": \"usage\"\n    }}>{`Usage`}</h2>\n    <p>{`Imagine you have generated your schema from a data source you don't control, and the generated schema looks like this:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`type Query {\n  books: BooksApiResponse\n}\n\ntype BooksApiResponse {\n  books: [Book]\n}\n\ntype Book {\n  title: String!\n  author: Author!\n  code: String\n}\n\ntype Author {\n  name: String!\n  age: Int!\n}\n`}</code></pre>\n    <p>{`As you can see you would have to request a GraphQL Document like the following to retrieve the list of books:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`{\n  books {\n    books {\n      title\n      author\n    }\n  }\n}\n`}</code></pre>\n    <p>{`This is not ideal because you have to request `}<inlineCode parentName=\"p\">{`books`}</inlineCode>{` as a child of `}<inlineCode parentName=\"p\">{`books`}</inlineCode>{`. In this case, hoisting the value from child to parent would lead to a cleaner schema and request Document.`}</p>\n    <p>{`To achieve this, you can add the following configuration to your Mesh config file:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`{\n  \"transforms\": [\n    {\n      \"replaceField\": {\n        \"replacements\": [\n          {\n            \"from\": {\n              \"type\": \"Query\",\n              \"field\": \"books\"\n            },\n            \"to\": {\n              \"type\": \"BooksApiResponse\",\n              \"field\": \"books\"\n            },\n            \"scope\": \"hoistValue\"\n          }\n        ]\n      }\n    }\n  ]\n}\n`}</code></pre>\n    <p>{`This will transform your schema from what you had above, to this:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`type Query {\n  books: [Book]\n}\n\ntype Book {\n  title: String!\n  author: Author!\n  code: String\n}\n\ntype Author {\n  name: String!\n  age: Int!\n}\n`}</code></pre>\n    <p>{`Allowing you to request a GraphQL document like this:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`{\n  books {\n    title\n    author\n  }\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"how-the-transform-works\"\n    }}>{`How the transform works`}</h2>\n    <p><inlineCode parentName=\"p\">{`from`}</inlineCode>{` defines your source, the field in the schema you want to replace.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`[\n  {\n    \"from\": {\n      \"type\": \"Query\",\n      \"field\": \"books\"\n    }\n  }\n]\n`}</code></pre>\n    <p>{`In this case, we want to replace the field `}<inlineCode parentName=\"p\">{`books`}</inlineCode>{` in the type `}<inlineCode parentName=\"p\">{`Query`}</inlineCode>{`, which has the type `}<inlineCode parentName=\"p\">{`BooksApiResponse`}</inlineCode>{`.`}</p>\n    <p><inlineCode parentName=\"p\">{`to`}</inlineCode>{` defines the target, and which field should replace your identified source field.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`{\n  \"to\": {\n    \"type\": \"BooksApiResponse\",\n    \"field\": \"books\"\n  }\n}\n`}</code></pre>\n    <p>{`To summarize, with the configuration above, we want the field `}<inlineCode parentName=\"p\">{`books`}</inlineCode>{` in type `}<inlineCode parentName=\"p\">{`Query`}</inlineCode>{` to be replaced from being of type `}<inlineCode parentName=\"p\">{`BooksApiResponse`}</inlineCode>{` to become type `}<inlineCode parentName=\"p\">{`[Book]`}</inlineCode>{`.`}</p>\n    <p>{`Finally, since we no longer have any reference to `}<inlineCode parentName=\"p\">{`BooksApiResponse`}</inlineCode>{` this becomes a loose type, which means the transform will purge it from the GraphQL schema.`}</p>\n    <h2 {...{\n      \"id\": \"transform-scopes\"\n    }}>{`Transform scopes`}</h2>\n    <p>{`We explored how to use the transform to replace field Types.\nThe transform always replaces the type of source field with the type of the target.`}</p>\n    <p>{`However, the transform also allows you to pass a scope property, which values can be `}<inlineCode parentName=\"p\">{`config`}</inlineCode>{` or `}<inlineCode parentName=\"p\">{`hoistValue`}</inlineCode>{`.`}</p>\n    <p>{`We could say that the scope property could also take a `}<inlineCode parentName=\"p\">{`type`}</inlineCode>{` value, but since it's the minimum requirement to replace the Type, this is considered the default scope and so it wouldn't make sense to pass it when you desire just this behavior.`}</p>\n    <h3 {...{\n      \"id\": \"scope-config\"\n    }}><inlineCode parentName=\"h3\">{`scope:`}</inlineCode>{` config`}</h3>\n    <p>{`The transform will replace the full field config when you pass `}<inlineCode parentName=\"p\">{`scope: config{:yaml}`}</inlineCode>{`.`}</p>\n    <p>{`A field config includes properties of the field such as `}<inlineCode parentName=\"p\">{`description`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`type`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`args`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`resolve`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`subscribe`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`deprecationReason`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`extensions`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`astNode`}</inlineCode>{`.`}</p>\n    <p>{`As you can see, this is very comprehensive as it includes things like arguments and the resolve and subscribes functions.`}</p>\n    <p>{`This can be useful when you have custom resolve functions on your target field. So you are happy to replace the source field entirely. However, you should be careful when you fully understand the implications of the behavior for your replaced field.`}</p>\n    <h3 {...{\n      \"id\": \"scope-hoistvalue\"\n    }}><inlineCode parentName=\"h3\">{`scope: hoistValue`}</inlineCode></h3>\n    <p>{`We have seen how `}<inlineCode parentName=\"p\">{`hoistValue`}</inlineCode>{` can be useful in the full example described in the \"How to use?\" paragraph.`}</p>\n    <p>{`Once again, by default, the transform will replace the Type of the field only.`}</p>\n    <p>{`When passing `}<inlineCode parentName=\"p\">{`scope: hoistValue{:yaml}`}</inlineCode>{` in addition to replacing the Type, the transform will wrap the resolve function of the original field (source) with an extra function. This function intercepts the return value of the resolver to ultimately return only the direct child property that has the same name as the target field; hence performing value hoisting.`}</p>\n    <p>{`Taking into account the original schema shared above, originally, `}<inlineCode parentName=\"p\">{`Query.books`}</inlineCode>{` would return a value like this:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`{\n  \"books\": {\n    \"books\": [\n      { \"title\": \"abc\", \"author\": \"def\" },\n      { \"title\": \"ghi\", \"author\": \"lmn\" }\n    ]\n  }\n}\n`}</code></pre>\n    <p>{`But the wrapping function applied to the original resolver, when passing a `}<inlineCode parentName=\"p\">{`hoistValue`}</inlineCode>{` scope, will change the value above to this:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`{\n  \"books\": [\n    { \"title\": \"abc\", \"author\": \"def\" },\n    { \"title\": \"ghi\", \"author\": \"lmn\" }\n  ]\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"additional-type-definitions\"\n    }}>{`Additional type definitions`}</h2>\n    <p>{`The examples shared so far are simple because we wanted to replace fields with other available fields in the original schema.`}</p>\n    <p>{`However, sometimes you might want to replace a field Type with something that is not available in the original schema.\nIn this case, the transform allows you to pass additional type definitions that will be injected into your schema to use them as target field Types.`}</p>\n    <p>{`Let's have a look at a Mesh config to be applied to the GraphQL schema shared above:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`{\n  \"transforms\": [\n    {\n      \"replaceField\": {\n        \"typeDefs\": \"type NewAuthor {\\\\n  age: String\\\\n}\\\\n\",\n        \"replacements\": [\n          {\n            \"from\": {\n              \"type\": \"Author\",\n              \"field\": \"age\"\n            },\n            \"to\": {\n              \"type\": \"NewAuthor\",\n              \"field\": \"age\"\n            }\n          }\n        ]\n      }\n    }\n  ]\n}\n`}</code></pre>\n    <p>{`The config above will change the type `}<inlineCode parentName=\"p\">{`Author`}</inlineCode>{` from this:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-diff\"\n      }}>{`type Author {\n  name: String!\n- age: Int!\n+ age: String\n}\n`}</code></pre>\n    <p>{`To this:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`type Author {\n  name: String!\n  age: String\n}\n`}</code></pre>\n    {\n      /* \n      ## Custom composers\n      Performing value hoisting or replacing the entire field config is powerful, but it might not always fully satisfy custom needs.\n      For instance, if you applied transforms to the bare schema (such as field renaming), the built-in value hoisting functionality won't work because you'd need to hoist the child property provided by the original schema, and not the renamed version.\n      The transform allows you to assign composers to replace the rule, which lets you define your custom logic on top of fields' resolve functions.\n      A composer is a function that wraps the resolve function, giving you access to this before it is executed. You can then intercept its output value so that finally you can also define a custom return value.\n      Let's look at an example.\n      Currently, our `Book` type has a `code` field; we want to replace this field and turn it into a boolean. Our logic assumes that if we have a book code, it means this book is available in our store.\n      Eventually, we want to completely replace `code` with `isAvailable`; as you can see, this requires implementing custom logic.\n      ```json\n      {\n       \"transforms\": [\n         {\n           \"replaceField\": {\n             \"typeDefs\": \"type NewBook {\\n  isAvailable: Boolean\\n}\\n\",\n             \"replacements\": [\n               {\n                 \"from\": {\n                   \"type\": \"Book\",\n                   \"field\": \"code\"\n                 },\n                 \"to\": {\n                   \"type\": \"NewBook\",\n                   \"field\": \"isAvailable\"\n                 },\n                 \"composer\": \"./customComposers.ts#isAvailable\"\n               }\n             ]\n           }\n         }\n       ]\n      }\n      ```\n      ```js\n      // customResolvers.js\n      module.exports = {\n       isAvailable: next => async (root, args, context, info) => {\n         // 'next' is the field resolve function\n         const code = await next(root, args, context, info)\n         return Boolean(code)\n       }\n      }\n      ```\n      Now our `code` field will return a Boolean as per custom logic implemented through the javascript function above.\n      ## Renaming fields\n      If we continue to elaborate on what we did above, when attaching composers to field resolvers to implement custom logic; it seems logical that a field that has been changed in Type and so return value, even with the addition of custom logic, has certainly evolved from the original field and so it would probably be best to rename it.\n      replaceField transform allows you to do that directly as part of the replacements rules; you just need to pass the `name` property to define a new name for your target field.\n      Let's wrap this up by adding a finishing touch to our schema:\n      ```json\n      {\n       \"transforms\": [\n         {\n           \"replaceField\": {\n             \"typeDefs\": \"type NewBook {\\n  isAvailable: Boolean\\n}\\n\",\n             \"replacements\": [\n               {\n                 \"from\": {\n                   \"type\": \"Query\",\n                   \"field\": \"books\"\n                 },\n                 \"to\": {\n                   \"type\": \"BooksApiResponse\",\n                   \"field\": \"books\"\n                 },\n                 \"scope\": \"hoistValue\"\n               },\n               {\n                 \"from\": {\n                   \"type\": \"Book\",\n                   \"field\": \"code\"\n                 },\n                 \"to\": {\n                   \"type\": \"NewBook\",\n                   \"field\": \"isAvailable\"\n                 },\n                 \"composer\": \"./customResolvers.js#isAvailable\",\n                 \"name\": \"isAvailable\"\n               }\n             ]\n           }\n         }\n       ]\n      }\n      ```\n      And now we have the following shiny GraphQL schema:\n      ```graphql\n      type Query {\n       books: [Book]\n      }\n      type Book {\n       title: String!\n       author: Author!\n       isAvailable: Boolean\n      }\n      type Author {\n       name: String!\n       age: Int!\n      }\n      ```\n      */\n    }\n    <h2 {...{\n      \"id\": \"config-api-reference\"\n    }}>{`Config API Reference`}</h2>\n    <ul>\n      <li parentName=\"ul\"><inlineCode parentName=\"li\">{`typeDefs`}</inlineCode>{` (type: `}<inlineCode parentName=\"li\">{`Any`}</inlineCode>{`) - Additional type definitions, used to replace field types`}</li>\n      <li parentName=\"ul\"><inlineCode parentName=\"li\">{`replacements`}</inlineCode>{` (type: `}<inlineCode parentName=\"li\">{`Array of Object`}</inlineCode>{`, required) - Array of rules to replace fields`}\n        <ul parentName=\"li\">\n          <li parentName=\"ul\"><inlineCode parentName=\"li\">{`from`}</inlineCode>{` (type: `}<inlineCode parentName=\"li\">{`Object`}</inlineCode>{`, required):`}\n            <ul parentName=\"li\">\n              <li parentName=\"ul\"><inlineCode parentName=\"li\">{`type`}</inlineCode>{` (type: `}<inlineCode parentName=\"li\">{`String`}</inlineCode>{`, required)`}</li>\n              <li parentName=\"ul\"><inlineCode parentName=\"li\">{`field`}</inlineCode>{` (type: `}<inlineCode parentName=\"li\">{`String`}</inlineCode>{`, required)`}</li>\n            </ul>\n          </li>\n          <li parentName=\"ul\"><inlineCode parentName=\"li\">{`to`}</inlineCode>{` (type: `}<inlineCode parentName=\"li\">{`Object`}</inlineCode>{`, required):`}\n            <ul parentName=\"li\">\n              <li parentName=\"ul\"><inlineCode parentName=\"li\">{`type`}</inlineCode>{` (type: `}<inlineCode parentName=\"li\">{`String`}</inlineCode>{`, required)`}</li>\n              <li parentName=\"ul\"><inlineCode parentName=\"li\">{`field`}</inlineCode>{` (type: `}<inlineCode parentName=\"li\">{`String`}</inlineCode>{`, required)`}</li>\n            </ul>\n          </li>\n          <li parentName=\"ul\"><inlineCode parentName=\"li\">{`scope`}</inlineCode>{` (type: `}<inlineCode parentName=\"li\">{`String (config | hoistValue)`}</inlineCode>{`)`}</li>\n          <li parentName=\"ul\"><inlineCode parentName=\"li\">{`composer`}</inlineCode>{` (type: `}<inlineCode parentName=\"li\">{`Any`}</inlineCode>{`)`}</li>\n          <li parentName=\"ul\"><inlineCode parentName=\"li\">{`name`}</inlineCode>{` (type: `}<inlineCode parentName=\"li\">{`String`}</inlineCode>{`)`}</li>\n        </ul>\n      </li>\n    </ul>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"names":["name","_frontmatter","InlineAlert","props","console","warn","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","mdxType","parentName","variant","slots","isMDXComponent"],"sourceRoot":""}