{"version":3,"file":"component---src-pages-reference-multiple-apis-md-fa2687863b2b60da11b0.js","mappings":"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","sources":["webpack://graphql-mesh-gateway/./src/pages/reference/multiple-apis.md"],"sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\n\nimport DefaultLayout from \"/home/runner/work/graphql-mesh-gateway/graphql-mesh-gateway/node_modules/@adobe/gatsby-theme-aio/src/components/MDXFilter/index.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst InlineAlert = makeShortcode(\"InlineAlert\");\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"multiple-apis-recipe\"\n    }}>{`Multiple APIs recipe`}</h1>\n    <p>{`This topic describes how to use multiple APIs. Your mesh can merge different data sources into a single unified GraphQL Schema, but it is not an alternative to Schema Stitching, Apollo Federation, Bare Schema Merging, or another merging strategy.`}</p>\n    <p>{`In addition to `}<inlineCode parentName=\"p\">{`@apollo/gateway`}</inlineCode>{`, API Mesh supports subscriptions out-of-box.`}</p>\n    <p><a parentName=\"p\" {...{\n        \"href\": \"https://product.voxmedia.com/2020/11/2/21494865/to-federate-or-stitch-a-graphql-gateway-revisited\"\n      }}>{`Learn more key differences between Schema Stitching and Apollo Federation`}</a></p>\n    <h2 {...{\n      \"id\": \"extending-graphql-schema-with-additionaltypedefs\"\n    }}>{`Extending GraphQL Schema with `}<inlineCode parentName=\"h2\">{`additionalTypeDefs`}</inlineCode></h2>\n    <p>{`You can add new types or fields to the current unified GraphQL Schema by using the `}<inlineCode parentName=\"p\">{`additionalTypeDefs`}</inlineCode>{` configuration field.`}</p>\n    <p>{`For example, if we have the StackExchange API in our Mesh configuration:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`{\n  \"sources\": [\n    {\n      \"name\": \"StackExchange\",\n      \"handler\": {\n        \"openapi\": {\n          \"source\": \"https://raw.githubusercontent.com/grokify/api-specs/master/stackexchange/stackexchange-api-v2.2_openapi-v3.0.yaml\"\n        }\n      }\n    }\n  ],\n  \"additionalTypeDefs\": \"extend type Query {\\\\n  listQuestionsFromStackOverflow(first: Int!): [Question]\\\\n}\\\\n\"\n}\n`}</code></pre>\n    <p>{`We might want to add a new field under the `}<inlineCode parentName=\"p\">{`Query`}</inlineCode>{` root type named `}<inlineCode parentName=\"p\">{`viewsInPastMonth`}</inlineCode>{`, but we will need a resolver for this field.`}</p>\n    <h2 {...{\n      \"id\": \"declare-a-resolver-to-the-new-additionaltypedefs-by-using-additionalresolvers\"\n    }}>{`Declare a resolver to the new `}<inlineCode parentName=\"h2\">{`additionalTypeDefs`}</inlineCode>{` by using `}<inlineCode parentName=\"h2\">{`additionalResolvers`}</inlineCode></h2>\n    <p>{`The `}<inlineCode parentName=\"p\">{`additionalResolvers`}</inlineCode>{` field will make our new field executable in the unified schema:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`{\n  \"sources\": [\n    {\n      \"name\": \"StackExchange\",\n      \"handler\": {\n        \"openapi\": {\n          \"source\": \"https://raw.githubusercontent.com/grokify/api-specs/master/stackexchange/stackexchange-api-v2.2_openapi-v3.0.yaml\"\n        }\n      }\n    }\n  ],\n  \"additionalTypeDefs\": \"extend type Query {\\\\n  listQuestionsFromStackOverflow(first: Int!): [Question]\\\\n}\\\\n\",\n  \"additionalResolvers\": [\n    {\n      \"targetTypeName\": \"Query\",\n      \"targetFieldName\": \"listQuestionsFromStackOverflow\",\n      \"sourceName\": \"StackExchange\",\n      \"sourceTypeName\": \"Query\",\n      \"sourceFieldName\": \"listQuestions\",\n      \"sourceArgs\": {\n        \"pagesize\": \"{args.first}\"\n      },\n      \"result\": \"items\"\n    }\n  ]\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"combining-schemas-using-declarative-api\"\n    }}>{`Combining Schemas using declarative API`}</h2>\n    <p>{`We learned that we can combine multiple APIs in a mesh using `}<inlineCode parentName=\"p\">{`additionalTypeDefs`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`additionalResolvers`}</inlineCode>{`.`}</p>\n    <p>{`The following example has two different OpenAPI sources. We will add two new fields to the `}<inlineCode parentName=\"p\">{`Cities`}</inlineCode>{` type, and those fields have return types from the `}<inlineCode parentName=\"p\">{`Weather`}</inlineCode>{` API.`}</p>\n    <p>{`To achieve this, we will use `}<inlineCode parentName=\"p\">{`additionalResolvers`}</inlineCode>{` inside the mesh configuration file.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`{\n  \"sources\": [\n    {\n      \"name\": \"Cities\",\n      \"handler\": {\n        \"openapi\": {\n          \"source\": \"https://api.apis.guru/v2/specs/mashape.com/geodb/1.0.0/swagger.json\",\n          \"operationHeaders\": {\n            \"X-RapidAPI-Key\": \"a12b3c456defg78hij9kl0123m4no5pqr6stuv789wxyz01a23\"\n          }\n        }\n      }\n    },\n    {\n      \"name\": \"Weather\",\n      \"handler\": {\n        \"openapi\": {\n          \"source\": \"https://api.apis.guru/v2/specs/weatherbit.io/2.0.0/swagger.json\"\n        }\n      }\n    }\n  ],\n  \"additionalTypeDefs\": \"extend type PopulatedPlaceSummary {\\\\n  dailyForecast: [Forecast]\\\\n  todayForecast: Forecast\\\\n}\\\\n\",\n  \"additionalResolvers\": [\n    {\n      \"targetTypeName\": \"PopulatedPlaceSummary\",\n      \"targetFieldName\": \"dailyForecast\",\n      \"requiredSelectionSet\": \"{\\\\n  latitude\\\\n  longitude\\\\n}\\\\n\",\n      \"sourceName\": \"Weather\",\n      \"sourceTypeName\": \"Query\",\n      \"sourceFieldName\": \"getForecastDailyLatLatLonLon\",\n      \"sourceArgs\": {\n        \"lat\": \"{root.latitude}\",\n        \"lon\": \"{root.longitude}\",\n        \"key\": \"{context.headers['x-weather-api-key']}\"\n      },\n      \"result\": \"data\"\n    },\n    {\n      \"type\": \"PopulatedPlaceSummary\",\n      \"field\": \"todayForecast\",\n      \"requiredSelectionSet\": \"{\\\\n  latitude\\\\n  longitude\\\\n}\\\\n\",\n      \"sourceName\": \"Weather\",\n      \"sourceTypeName\": \"Query\",\n      \"sourceFieldName\": \"getForecastDailyLatLatLonLon\",\n      \"sourceArgs\": {\n        \"lat\": \"{root.latitude}\",\n        \"lon\": \"{root.longitude}\",\n        \"key\": \"{context.headers['x-weather-api-key']}\"\n      },\n      \"result\": \"data[0]\"\n    }\n  ]\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"merging-types-from-different-sources-type-merging\"\n    }}>{`Merging types from different sources (Type Merging)`}</h2>\n    <p>{`Imagine you have two different services, `}<inlineCode parentName=\"p\">{`Books`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`Authors`}</inlineCode>{`, which are exposing the following schemas:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`# Authors\ntype Query {\n  authors(ids: [ID!]): [Author!]!\n  author(id: ID!): Author!\n}\n\ntype Author {\n  id: ID!\n  name: String!\n}\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`# Books\ntype Query {\n  books(ids: [ID!]): [Book!]!\n  book(id: ID!): Book!\n  authorWithBooks(id: ID!): Author!\n  authorsWithBooks(ids: [ID!]): [Author!]!\n}\n\ntype Book {\n  id: ID!\n  title: String!\n  authorId: ID!\n}\n\ntype AuthorWithBooks {\n  id: ID!\n  books: [Book!]!\n}\n`}</code></pre>\n    <p>{`Then you could use the `}<a parentName=\"p\" {...{\n        \"href\": \"transforms/rename.md\"\n      }}><inlineCode parentName=\"a\">{`Rename`}</inlineCode></a>{` transform to rename `}<inlineCode parentName=\"p\">{`AuthorWithBooks`}</inlineCode>{` to `}<inlineCode parentName=\"p\">{`Author`}</inlineCode>{`.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`[\n  {\n    \"sources\": [\n      {\n        \"name\": \"BookService\",\n        \"handler\": null,\n        \"transforms\": [\n          {\n            \"rename\": {\n              \"renames\": [\n                {\n                  \"from\": {\n                    \"type\": \"AuthorWithBooks\"\n                  },\n                  \"to\": {\n                    \"type\": \"Author\"\n                  }\n                },\n                {\n                  \"from\": {\n                    \"type\": \"Query\",\n                    \"field\": \"authorWithBooks\"\n                  },\n                  \"to\": {\n                    \"type\": \"Query\",\n                    \"field\": \"author\"\n                  }\n                }\n              ]\n            }\n          }\n        ]\n      }\n    ]\n  }\n]\n`}</code></pre>\n    <p>{`After that `}<inlineCode parentName=\"p\">{`rename`}</inlineCode>{`, you would expect the following query to work, but it will fail because the mesh does not know which field belongs to which source and how to combine those.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`{\n  author(id: 0) {\n    id # This field is common\n    name # This field is from \\`AuthorService\\`\n    books { # This field is from \\`BookService\\`\n      id\n      title\n    }\n  }\n}\n`}</code></pre>\n    <p>{`You could add `}<inlineCode parentName=\"p\">{`additionalResolvers`}</inlineCode>{`, extract `}<inlineCode parentName=\"p\">{`books`}</inlineCode>{` from `}<inlineCode parentName=\"p\">{`AuthorWithBooks`}</inlineCode>{`, and return it as a `}<inlineCode parentName=\"p\">{`books`}</inlineCode>{` field of `}<inlineCode parentName=\"p\">{`Author`}</inlineCode>{` type, but this is unnecessarily complicated. So instead, we'll use Type Merging.`}</p>\n    <p>{`The following example indicates how to fetch entities from different sources:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`{\n  \"sources\": [\n    {\n      \"name\": \"AuthorService\",\n      \"handler\": null,\n      \"transforms\": [\n        {\n          \"typeMerging\": {\n            \"queryFields\": [\n              {\n                \"queryFieldName\": \"author\",\n                \"keyField\": \"id\"\n              }\n            ]\n          }\n        }\n      ]\n    },\n    {\n      \"name\": \"BookService\",\n      \"handler\": null,\n      \"transforms\": [\n        {\n          \"rename\": {\n            \"renames\": [\n              {\n                \"from\": {\n                  \"type\": \"AuthorWithBooks\"\n                },\n                \"to\": {\n                  \"type\": \"Author\"\n                }\n              },\n              {\n                \"from\": {\n                  \"type\": \"Query\",\n                  \"field\": \"authorWithBooks\"\n                },\n                \"to\": {\n                  \"type\": \"Query\",\n                  \"field\": \"author\"\n                }\n              },\n              {\n                \"from\": {\n                  \"type\": \"Query\",\n                  \"field\": \"authorsWithBooks\"\n                },\n                \"to\": {\n                  \"type\": \"Query\",\n                  \"field\": \"authors\"\n                }\n              }\n            ]\n          }\n        },\n        {\n          \"typeMerging\": {\n            \"queryFields\": [\n              {\n                \"queryFieldName\": \"book\",\n                \"keyField\": \"id\"\n              },\n              {\n                \"queryFieldName\": \"author\",\n                \"keyField\": \"id\"\n              }\n            ]\n          }\n        }\n      ]\n    }\n  ]\n}\n`}</code></pre>\n    <p>{`Now the previous query will work as expected.`}</p>\n    <p><a parentName=\"p\" {...{\n        \"href\": \"transforms/type-merging.md\"\n      }}>{`Learn more about the Type Merging transform`}</a>{`.`}</p>\n    <h2 {...{\n      \"id\": \"batching-requests-between-sources-to-prevent-an-n1-problem\"\n    }}>{`Batching requests between sources to prevent an N+1 problem`}</h2>\n    <h3 {...{\n      \"id\": \"in-type-merging\"\n    }}>{`In type merging`}</h3>\n    <p>{`The previous example works fine, but there is an N+1 problem. It sends `}<inlineCode parentName=\"p\">{`n`}</inlineCode>{` requests for `}<inlineCode parentName=\"p\">{`n`}</inlineCode>{` entities. But we have `}<inlineCode parentName=\"p\">{`authors`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`books`}</inlineCode>{`. Type Merging is smart enough to handle batching if you point it to a field that returns a list of entities. Let's update our mesh to the following:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`{\n  \"sources\": [\n    {\n      \"name\": \"AuthorService\",\n      \"handler\": null,\n      \"transforms\": [\n        {\n          \"typeMerging\": {\n            \"queryFields\": [\n              {\n                \"queryFieldName\": \"authors\",\n                \"keyField\": \"id\"\n              }\n            ]\n          }\n        }\n      ]\n    },\n    {\n      \"name\": \"BookService\",\n      \"handler\": null,\n      \"transforms\": [\n        {\n          \"rename\": {\n            \"renames\": [\n              {\n                \"from\": {\n                  \"type\": \"AuthorWithBooks\"\n                },\n                \"to\": {\n                  \"type\": \"Author\"\n                }\n              },\n              {\n                \"from\": {\n                  \"type\": \"Query\",\n                  \"field\": \"authorWithBooks\"\n                },\n                \"to\": {\n                  \"type\": \"Query\",\n                  \"field\": \"author\"\n                }\n              },\n              {\n                \"from\": {\n                  \"type\": \"Query\",\n                  \"field\": \"authorsWithBooks\"\n                },\n                \"to\": {\n                  \"type\": \"Query\",\n                  \"field\": \"authors\"\n                }\n              }\n            ]\n          }\n        },\n        {\n          \"typeMerging\": {\n            \"queryFields\": [\n              {\n                \"queryFieldName\": \"books\",\n                \"keyField\": \"id\"\n              },\n              {\n                \"queryFieldName\": \"authors\",\n                \"keyField\": \"id\"\n              }\n            ]\n          }\n        }\n      ]\n    }\n  ]\n}\n`}</code></pre>\n    <p>{`And now it batches the requests to the inner sources.`}</p>\n    <h3 {...{\n      \"id\": \"in-regular-additionalresolvers\"\n    }}>{`In regular `}<inlineCode parentName=\"h3\">{`additionalResolvers`}</inlineCode></h3>\n    <p>{`In the following example, we want to have a field called `}<inlineCode parentName=\"p\">{`author`}</inlineCode>{` under `}<inlineCode parentName=\"p\">{`Book`}</inlineCode>{` property and point it to the `}<inlineCode parentName=\"p\">{`author`}</inlineCode>{` property.`}</p>\n    <p>{`Normally, we would use the following definitions:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`{\n  \"additionalTypeDefs\": \"extend type Book {\\\\n  author: Author\\\\n}\\\\n\",\n  \"additionalResolvers\": [\n    {\n      \"sourceName\": \"AuthorService\",\n      \"sourceTypeName\": \"Query\",\n      \"sourceFieldName\": \"author\",\n      \"sourceArgs\": {\n        \"id\": \"{root.authorId}\"\n      },\n      \"targetTypeName\": \"Book\",\n      \"targetFieldName\": \"author\",\n      \"requiredSelectionSet\": \"{authorId}\"\n    }\n  ]\n}\n`}</code></pre>\n    <p>{`This creates an N+1 problem that we can solve by using the following format:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`{\n  \"additionalResolvers\": [\n    {\n      \"sourceName\": \"AuthorService\",\n      \"sourceTypeName\": \"Query\",\n      \"sourceFieldName\": \"authors\",\n      \"keyField\": \"authorId\",\n      \"keysArg\": \"ids\",\n      \"targetTypeName\": \"Book\",\n      \"targetFieldName\": \"author\"\n    }\n  ]\n}\n`}</code></pre>\n    <p>{`Now your mesh will batch the queries of `}<inlineCode parentName=\"p\">{`Book.author`}</inlineCode>{` by using the `}<inlineCode parentName=\"p\">{`authorId`}</inlineCode>{` field in `}<inlineCode parentName=\"p\">{`Query.authors`}</inlineCode>{`.`}</p>\n    <h2 {...{\n      \"id\": \"consuming-apollo-federation-services\"\n    }}>{`Consuming Apollo Federation Services`}</h2>\n    <p>{`The mesh uses `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/gmac/schema-stitching-handbook/tree/master/federation-services\"\n      }}>{`Schema Stitching`}</a>{` to consume the existing Apollo Federation services, so you can combine Federation and Type Merging.`}</p>\n    <p>{`Follow the Apollo Federation spec and integrate your existing Federated services. Your mesh can mix and match Federation and Stitching approaches including all other transforms (Type Merging, Rename, Filter, etc.).`}</p>\n    <p>{`You can also transform your existing non-federated schemas into a federated service.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`{\n  \"sources\": [\n    {\n      \"name\": \"accounts\",\n      \"handler\": {\n        \"graphql\": {\n          \"endpoint\": \"<your_url>\"\n        }\n      },\n      \"transforms\": [\n        {\n          \"federation\": {\n            \"types\": [\n              {\n                \"name\": \"Query\",\n                \"config\": {\n                  \"extend\": true\n                }\n              },\n              {\n                \"name\": \"User\",\n                \"config\": {\n                  \"keyFields\": [\n                    \"id\"\n                  ],\n                  \"resolveReference\": {\n                    \"queryFieldName\": \"user\"\n                  }\n                }\n              }\n            ]\n          }\n        }\n      ]\n    },\n    {\n      \"name\": \"reviews\",\n      \"handler\": {\n        \"graphql\": {\n          \"endpoint\": \"<your_url>\"\n        }\n      }\n    },\n    {\n      \"name\": \"products\",\n      \"handler\": {\n        \"graphql\": {\n          \"endpoint\": \"<your_url>\"\n        }\n      }\n    },\n    {\n      \"name\": \"inventory\",\n      \"handler\": {\n        \"graphql\": {\n          \"endpoint\": \"<your_url>\"\n        }\n      }\n    }\n  ]\n}\n`}</code></pre>\n    <InlineAlert variant=\"info\" slots=\"text\" mdxType=\"InlineAlert\" />\n    <p>{` You can view the `}<a parentName=\"p\" {...{\n        \"href\": \"transforms/federation.md\"\n      }}>{`federation transformer`}</a>{` documentation to learn more about adding federation metadata to a non-federated GraphQL Schema.`}</p>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"names":["name","_frontmatter","InlineAlert","props","console","warn","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","mdxType","parentName","variant","slots","isMDXComponent"],"sourceRoot":""}