"use strict";(self.webpackChunkgraphql_mesh_gateway=self.webpackChunkgraphql_mesh_gateway||[]).push([[5525],{90023:function(e,t,o){o.r(t),o.d(t,{_frontmatter:function(){return m},default:function(){return h}});var n=o(87462),r=o(45987),a=(o(35776),o(3905)),c=o(91515);const s=["components"],m={},i={_frontmatter:m},d=c.Z;function h(e){let{components:t}=e,o=(0,r.Z)(e,s);return(0,a.mdx)(d,(0,n.Z)({},i,o,{components:t,mdxType:"MDXLayout"}),(0,a.mdx)("h1",{id:"use-cases"},"Use cases"),(0,a.mdx)("h2",{id:"connecting-to-adobe-commerce-services"},"Connecting to Adobe Commerce services"),(0,a.mdx)("p",null,"When connecting the Adobe Commerce REST API and the Commerce Catalog Service, you will have conflicting object names. For example, the XYZ object exists in both the Adobe Commerce REST API, and the Commerce Catalog service. Using the ",(0,a.mdx)("a",{parentName:"p",href:"./transforms/prefix.md"},(0,a.mdx)("inlineCode",{parentName:"a"},"prefix")," transform"),", you can append different prefixes to each source, to avoid having conflicting object names."),(0,a.mdx)("h2",{id:"storefront-integration"},"Storefront integration"),(0,a.mdx)("p",null,"Adobe Commerce users can consider API Mesh as a low-code way to integrate other APIs to the Storefront and Storefront Management APIs. It also provides a way for the Storefront API and the Storefront Management APIs to communicate with each other."))}h.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-gateway-use-cases-md-c6d27f3bbe5251e893e8.js.map